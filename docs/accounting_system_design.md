# Ø³ÛŒØ³ØªÙ… Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ Ø§ÛŒØ±Ø§Ù†ÛŒ Ø³ÙØ±ÙˆØ§Ù† - Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ú©Ø§Ù…Ù„

**Ù†Ø³Ø®Ù‡**: 3.0  
**ØªØ§Ø±ÛŒØ®**: 2025/01/27  
**ÙˆØ¶Ø¹ÛŒØª**: âœ… **100% Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯Ù‡ - Backend + Frontend Ø¢Ù…Ø§Ø¯Ù‡ ØªÙˆÙ„ÛŒØ¯**

---

## ğŸ‰ **ÙˆØ¶Ø¹ÛŒØª Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ**

### **âœ… Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ú©Ø§Ù…Ù„ (100%)**
Ø³ÛŒØ³ØªÙ… Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ Ø§ÛŒØ±Ø§Ù†ÛŒ Ø³ÙØ±ÙˆØ§Ù† Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª **100% Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ** Ø´Ø¯Ù‡ Ùˆ Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¯Ø± Ù…Ø­ÛŒØ· ØªÙˆÙ„ÛŒØ¯ Ø§Ø³Øª.

### **ğŸ“Š Ø¢Ù…Ø§Ø± Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ:**
- **ğŸ—„ï¸ Database Schema**: 11 Ù…Ø¯Ù„ Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ Ú©Ø§Ù…Ù„
- **ğŸ”Œ API Endpoints**: 25+ endpoint Ú©Ø§Ù…Ù„
- **ğŸ“ Backend Services**: 3 Ø³Ø±ÙˆÛŒØ³ Ø§ØµÙ„ÛŒ (1950+ Ø®Ø· Ú©Ø¯)
- **ğŸ¨ Frontend Pages**: 5 ØµÙØ­Ù‡ Ú©Ø§Ù…Ù„ Ø¨Ø§ Ø±Ø§Ø¨Ø· ÙØ§Ø±Ø³ÛŒ
- **ğŸ“‹ Iranian Chart of Accounts**: 45 Ø­Ø³Ø§Ø¨ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯
- **ğŸ”„ Migration**: Ù…ÙˆÙÙ‚ Ùˆ Prisma client ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯Ù‡
- **ğŸ“š Documentation**: Ù…Ø³ØªÙ†Ø¯Ø§Øª Ú©Ø§Ù…Ù„ 400+ Ø®Ø·

### **ğŸ† ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯Ù‡:**

#### **âœ… Backend (Ú©Ø§Ù…Ù„)**
- âœ… **Ø¯ÙØªØ± Ø­Ø³Ø§Ø¨â€ŒÙ‡Ø§ÛŒ Ø§ÛŒØ±Ø§Ù†ÛŒ** - 45 Ø­Ø³Ø§Ø¨ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ Ø¨Ø§ Ú©Ø¯Ú¯Ø°Ø§Ø±ÛŒ 1000-5000
- âœ… **Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ Ø¯ÙˆØ·Ø±ÙÙ‡** - Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± ØªØ¹Ø§Ø¯Ù„ Ø¨Ø¯Ù‡Ú©Ø§Ø±/Ø¨Ø³ØªØ§Ù†Ú©Ø§Ø±
- âœ… **Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ø³Ù†Ø§Ø¯ Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ** - Ø§ÛŒØ¬Ø§Ø¯ØŒ ØªØµÙˆÛŒØ¨ØŒ Ø§Ø¨Ø·Ø§Ù„
- âœ… **ØµÙˆØ±Øªâ€ŒÙ‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ** - ØªØ±Ø§Ø²Ù†Ø§Ù…Ù‡ØŒ Ø³ÙˆØ¯ Ùˆ Ø²ÛŒØ§Ù†ØŒ Ø¬Ø±ÛŒØ§Ù† ÙˆØ¬Ù‡ Ù†Ù‚Ø¯
- âœ… **Ù†Ø³Ø¨Øªâ€ŒÙ‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ** - Ù†Ù‚Ø¯ÛŒÙ†Ú¯ÛŒØŒ Ø³ÙˆØ¯Ø¢ÙˆØ±ÛŒØŒ Ø§Ù‡Ø±Ù…ÛŒ
- âœ… **ØªÙ‚ÙˆÛŒÙ… Ø´Ù…Ø³ÛŒ** - Ø´Ù…Ø§Ø±Ù‡â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø§Ø³Ù†Ø§Ø¯ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø³Ø§Ù„ Ø´Ù…Ø³ÛŒ
- âœ… **Ù…Ø±Ø§Ú©Ø² Ù‡Ø²ÛŒÙ†Ù‡** - ØªØ®ØµÛŒØµ Ù‡Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ Ø¨Ù‡ Ù…Ø±Ø§Ú©Ø² Ù…Ø®ØªÙ„Ù
- âœ… **ØªÙˆÙ„ÛŒØ¯ Ø®ÙˆØ¯Ú©Ø§Ø± Ø§Ø³Ù†Ø§Ø¯** - Ø§Ø² ÙØ±ÙˆØ´ Ùˆ Ø®Ø±ÛŒØ¯ POS
- âœ… **ØªØ±Ø§Ø²Ø¢Ø²Ù…Ø§ÛŒØ´ÛŒ** - Ù…Ø­Ø§Ø³Ø¨Ø§Øª real-time
- âœ… **ØµÙˆØ±Øªâ€ŒÙ‡Ø§ÛŒ ØªØ·Ø¨ÛŒÙ‚ÛŒ** - Ù…Ù‚Ø§ÛŒØ³Ù‡ Ø¯ÙˆØ±Ù‡â€ŒØ§ÛŒ
- âœ… **Audit Trail** - Ø±Ø¯ÛŒØ§Ø¨ÛŒ Ú©Ø§Ù…Ù„ ØªØºÛŒÛŒØ±Ø§Øª

#### **âœ… Frontend (Ú©Ø§Ù…Ù„)**
- âœ… **Accounting Dashboard** - Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ø§ØµÙ„ÛŒ Ø¨Ø§ Ø¢Ù…Ø§Ø± real-time Ùˆ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø³Ø±ÛŒØ¹
- âœ… **Chart of Accounts Management** - Ù…Ø¯ÛŒØ±ÛŒØª Ø¯ÙØªØ± Ø­Ø³Ø§Ø¨â€ŒÙ‡Ø§ Ø¨Ø§ Ù†Ù…Ø§ÛŒ Ø¯Ø±Ø®ØªÛŒ
- âœ… **Journal Entries Management** - Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ù…Ù„ Ø§Ø³Ù†Ø§Ø¯ Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ
- âœ… **Financial Statements Page** - Ù†Ù…Ø§ÛŒØ´ ØªØ±Ø§Ø²Ù†Ø§Ù…Ù‡ØŒ Ø³ÙˆØ¯ Ùˆ Ø²ÛŒØ§Ù†ØŒ Ø¬Ø±ÛŒØ§Ù† ÙˆØ¬Ù‡ Ù†Ù‚Ø¯
- âœ… **Advanced Reports Page** - Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§ÛŒ ØªØ­Ù„ÛŒÙ„ÛŒ Ùˆ Ù†Ù…ÙˆØ¯Ø§Ø±ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡
- âœ… **Navigation Integration** - Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù† Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ (ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±Ø§Ù†)
- âœ… **Persian Localization** - Ø±Ø§Ø¨Ø· Ú©Ø§Ø±Ø¨Ø±ÛŒ ÙØ§Ø±Ø³ÛŒ Ú©Ø§Ù…Ù„
- âœ… **Responsive Design** - Ø·Ø±Ø§Ø­ÛŒ ÙˆØ§Ú©Ù†Ø´â€ŒÚ¯Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ Ø¯Ø³ØªÚ¯Ø§Ù‡â€ŒÙ‡Ø§
- âœ… **Error Handling** - Ù…Ø¯ÛŒØ±ÛŒØª Ø®Ø·Ø§ Ùˆ Ø­Ø§Ù„Øªâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ
- âœ… **TypeScript Integration** - ØªØ§ÛŒÙ¾â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ù…Ù„ Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ Ú©Ø§Ù…Ù¾ÙˆÙ†Ù†Øªâ€ŒÙ‡Ø§

---

## ğŸ¯ **Ø§Ù‡Ø¯Ø§Ù Ø³ÛŒØ³ØªÙ… Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ**

### **Ù‡Ø¯Ù Ø§ØµÙ„ÛŒ**
ØªÙˆØ³Ø¹Ù‡ ÛŒÚ© **Ø³ÛŒØ³ØªÙ… Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ Ú©Ø§Ù…Ù„ Ùˆ ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡** Ú©Ù‡ Ø¨Ù‡ Ø·ÙˆØ± Ù…Ø³ØªÙ‚ÛŒÙ… Ø¨Ø§ Ø³ÛŒØ³ØªÙ… Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø³ÙØ±ÙˆØ§Ù† Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ø±Ù‚Ø±Ø§Ø± Ú©Ù†Ø¯ Ùˆ ØªÙ…Ø§Ù… Ø¬Ù†Ø¨Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ Ú©Ø³Ø¨â€ŒÙˆÚ©Ø§Ø± Ø±Ø§ Ù¾ÙˆØ´Ø´ Ø¯Ù‡Ø¯.

### **Ø§Ù‡Ø¯Ø§Ù ÙØ±Ø¹ÛŒ**
- ğŸ“Š **Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ Ø¯ÙˆØ·Ø±ÙÙ‡ Ú©Ø§Ù…Ù„** Ø¨Ø§ Ø±Ø¹Ø§ÛŒØª Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯Ù‡Ø§ÛŒ Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ
- ğŸ’° **ØªØ­Ù„ÛŒÙ„ Ø³ÙˆØ¯Ø¢ÙˆØ±ÛŒ Ø¯Ù‚ÛŒÙ‚** Ù‡Ø± Ú©Ø§Ù„Ø§ØŒ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ùˆ ØªØ£Ù…ÛŒÙ†â€ŒÚ©Ù†Ù†Ø¯Ù‡
- ğŸ“ˆ **ØµÙˆØ±Øªâ€ŒÙ‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±** (ØªØ±Ø§Ø²Ù†Ø§Ù…Ù‡ØŒ Ø³ÙˆØ¯ Ùˆ Ø²ÛŒØ§Ù†ØŒ Ø¬Ø±ÛŒØ§Ù† ÙˆØ¬Ù‡ Ù†Ù‚Ø¯)
- ğŸ¯ **Ù…Ø¯ÛŒØ±ÛŒØª Ø¨ÙˆØ¯Ø¬Ù‡** Ùˆ ØªØ­Ù„ÛŒÙ„ Ø§Ù†Ø­Ø±Ø§Ù
- ğŸ¢ **Ù…Ø±Ø§Ú©Ø² Ù‡Ø²ÛŒÙ†Ù‡** Ùˆ ØªØ­Ù„ÛŒÙ„ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø¨Ø®Ø´â€ŒÙ‡Ø§
- ğŸ” **Ù†Ø¸Ø§Ø±Øª Ù…Ø§Ù„ÛŒ real-time** Ùˆ Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯

---

## ğŸ—ï¸ **Architecture Ø³ÛŒØ³ØªÙ… Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ**

### **Ø³Ø§Ø®ØªØ§Ø± Ú©Ù„ÛŒ**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Servaan Accounting System               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚  Chart of       â”‚  â”‚  Journal        â”‚               â”‚
â”‚  â”‚  Accounts       â”‚  â”‚  Entries        â”‚               â”‚ 
â”‚  â”‚  (Ø¯ÙØªØ± Ø­Ø³Ø§Ø¨â€ŒÙ‡Ø§)   â”‚  â”‚  (Ø§Ø³Ù†Ø§Ø¯ Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ) â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚           â”‚                     â”‚                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚  Cost Centers   â”‚  â”‚  Budget         â”‚               â”‚
â”‚  â”‚  (Ù…Ø±Ø§Ú©Ø² Ù‡Ø²ÛŒÙ†Ù‡)    â”‚  â”‚  Management     â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚           â”‚                     â”‚                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚           Financial Statements Engine               â”‚â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚â”‚
â”‚  â”‚  â”‚Balance Sheetâ”‚ â”‚Income Stmt. â”‚ â”‚Cash Flow    â”‚   â”‚â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                  Integration Layer                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚  Inventory      â”‚  â”‚  POS System     â”‚               â”‚ 
â”‚  â”‚  Integration    â”‚  â”‚  Integration    â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“Š **Chart of Accounts (Ø¯ÙØªØ± Ø­Ø³Ø§Ø¨â€ŒÙ‡Ø§)**

### **Ø³Ø§Ø®ØªØ§Ø± Ø­Ø³Ø§Ø¨â€ŒÙ‡Ø§**

```typescript
// Chart of Accounts Structure
interface ChartOfAccount {
  id: string;
  accountCode: string;    // Ú©Ø¯ Ø­Ø³Ø§Ø¨ (Ù…Ø«Ù„Ø§Ù‹: 1101)
  accountName: string;    // Ù†Ø§Ù… Ø­Ø³Ø§Ø¨
  accountType: AccountType;
  parentAccountId?: string;
  level: number;          // Ø³Ø·Ø­ Ø­Ø³Ø§Ø¨ Ø¯Ø± Ø¯Ø±Ø®Øª
  normalBalance: 'DEBIT' | 'CREDIT';
  isActive: boolean;
  children?: ChartOfAccount[];
}

enum AccountType {
  ASSET = 'ASSET',           // Ø¯Ø§Ø±Ø§ÛŒÛŒ
  LIABILITY = 'LIABILITY',   // Ø¨Ø¯Ù‡ÛŒ  
  EQUITY = 'EQUITY',         // Ø­Ù‚ÙˆÙ‚ ØµØ§Ø­Ø¨Ø§Ù† Ø³Ù‡Ø§Ù…
  REVENUE = 'REVENUE',       // Ø¯Ø±Ø¢Ù…Ø¯
  EXPENSE = 'EXPENSE'        // Ù‡Ø²ÛŒÙ†Ù‡
}
```

### **Ø·Ø±Ø­ Ø­Ø³Ø§Ø¨â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´â€ŒÙØ±Ø¶ (Ø§ÛŒØ±Ø§Ù†ÛŒ)**

```json
{
  "1000": {
    "name": "Ø¯Ø§Ø±Ø§ÛŒÛŒâ€ŒÙ‡Ø§",
    "type": "ASSET",
    "level": 1,
    "children": {
      "1100": {
        "name": "Ø¯Ø§Ø±Ø§ÛŒÛŒâ€ŒÙ‡Ø§ÛŒ Ø¬Ø§Ø±ÛŒ",
        "level": 2,
        "children": {
          "1101": "ØµÙ†Ø¯ÙˆÙ‚",
          "1102": "Ø¨Ø§Ù†Ú©",
          "1103": "Ø­Ø³Ø§Ø¨â€ŒÙ‡Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØªÙ†ÛŒ",
          "1104": "Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©Ø§Ù„Ø§",
          "1105": "Ù¾ÛŒØ´â€ŒÙ¾Ø±Ø¯Ø§Ø®Øªâ€ŒÙ‡Ø§"
        }
      },
      "1200": {
        "name": "Ø¯Ø§Ø±Ø§ÛŒÛŒâ€ŒÙ‡Ø§ÛŒ Ø«Ø§Ø¨Øª",
        "level": 2,
        "children": {
          "1201": "Ø³Ø§Ø®ØªÙ…Ø§Ù†",
          "1202": "ØªØ¬Ù‡ÛŒØ²Ø§Øª",
          "1203": "Ø§Ø³ØªÙ‡Ù„Ø§Ú© Ø§Ù†Ø¨Ø§Ø´ØªÙ‡"
        }
      }
    }
  },
  "2000": {
    "name": "Ø¨Ø¯Ù‡ÛŒâ€ŒÙ‡Ø§",
    "type": "LIABILITY",
    "level": 1,
    "children": {
      "2100": {
        "name": "Ø¨Ø¯Ù‡ÛŒâ€ŒÙ‡Ø§ÛŒ Ø¬Ø§Ø±ÛŒ",
        "level": 2,
        "children": {
          "2101": "Ø­Ø³Ø§Ø¨â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®ØªÙ†ÛŒ",
          "2102": "Ù…Ø§Ù„ÛŒØ§Øª Ù¾Ø±Ø¯Ø§Ø®ØªÙ†ÛŒ",
          "2103": "Ø¨ÛŒÙ…Ù‡ Ù¾Ø±Ø¯Ø§Ø®ØªÙ†ÛŒ"
        }
      }
    }
  },
  "3000": {
    "name": "Ø­Ù‚ÙˆÙ‚ ØµØ§Ø­Ø¨Ø§Ù† Ø³Ù‡Ø§Ù…",
    "type": "EQUITY",
    "level": 1,
    "children": {
      "3101": "Ø³Ø±Ù…Ø§ÛŒÙ‡",
      "3102": "Ø³ÙˆØ¯ Ø§Ù†Ø¨Ø§Ø´ØªÙ‡"
    }
  },
  "4000": {
    "name": "Ø¯Ø±Ø¢Ù…Ø¯Ù‡Ø§",
    "type": "REVENUE",
    "level": 1,
    "children": {
      "4101": "ÙØ±ÙˆØ´ Ú©Ø§Ù„Ø§",
      "4102": "Ø¯Ø±Ø¢Ù…Ø¯Ù‡Ø§ÛŒ Ù…ØªÙØ±Ù‚Ù‡"
    }
  },
  "5000": {
    "name": "Ù‡Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§",
    "type": "EXPENSE",
    "level": 1,
    "children": {
      "5100": {
        "name": "Ø¨Ù‡Ø§ÛŒ ØªÙ…Ø§Ù… Ø´Ø¯Ù‡ Ú©Ø§Ù„Ø§ÛŒ ÙØ±ÙˆØ®ØªÙ‡ Ø´Ø¯Ù‡",
        "level": 2,
        "children": {
          "5101": "Ø®Ø±ÛŒØ¯ Ú©Ø§Ù„Ø§",
          "5102": "Ø­Ù…Ù„ Ùˆ Ù†Ù‚Ù„ Ø®Ø±ÛŒØ¯"
        }
      },
      "5200": {
        "name": "Ù‡Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„ÛŒØ§ØªÛŒ",
        "level": 2,
        "children": {
          "5201": "Ø­Ù‚ÙˆÙ‚ Ùˆ Ø¯Ø³ØªÙ…Ø²Ø¯",
          "5202": "Ø§Ø¬Ø§Ø±Ù‡",
          "5203": "Ø¨Ø±Ù‚ Ùˆ Ú¯Ø§Ø²",
          "5204": "ØªÙ„ÙÙ† Ùˆ Ø§ÛŒÙ†ØªØ±Ù†Øª",
          "5205": "ØªØ¨Ù„ÛŒØºØ§Øª Ùˆ Ø¨Ø§Ø²Ø§Ø±ÛŒØ§Ø¨ÛŒ"
        }
      }
    }
  }
}
```

---

## ğŸ“ **Journal Entries (Ø§Ø³Ù†Ø§Ø¯ Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ)**

### **Ø³Ø§Ø®ØªØ§Ø± Ø§Ø³Ù†Ø§Ø¯**

```typescript
interface JournalEntry {
  id: string;
  entryNumber: string;      // Ø´Ù…Ø§Ø±Ù‡ Ø³Ù†Ø¯ (Ø®ÙˆØ¯Ú©Ø§Ø±)
  entryDate: Date;         // ØªØ§Ø±ÛŒØ® Ø³Ù†Ø¯
  reference?: string;      // Ù…Ø±Ø¬Ø¹ (Ø´Ù…Ø§Ø±Ù‡ ÙØ§Ú©ØªÙˆØ±ØŒ etc.)
  description: string;     // Ø´Ø±Ø­ Ú©Ù„ÛŒ Ø³Ù†Ø¯
  totalAmount: number;     // Ù…Ø¨Ù„Øº Ú©Ù„ Ø³Ù†Ø¯
  status: 'DRAFT' | 'POSTED' | 'REVERSED';
  lines: JournalEntryLine[];
  createdBy: string;       // Ú©Ø§Ø±Ø¨Ø± Ø§ÛŒØ¬Ø§Ø¯Ú©Ù†Ù†Ø¯Ù‡
  approvedBy?: string;     // Ú©Ø§Ø±Ø¨Ø± ØªØ£ÛŒÛŒØ¯Ú©Ù†Ù†Ø¯Ù‡
  approvedAt?: Date;
  reversedBy?: string;     // Ú©Ø§Ø±Ø¨Ø± Ø§Ø¨Ø·Ø§Ù„â€ŒÚ©Ù†Ù†Ø¯Ù‡
  reversedAt?: Date;
  reversalReason?: string;
  createdAt: Date;
  updatedAt: Date;
}

interface JournalEntryLine {
  id: string;
  accountId: string;       // Ø´Ù†Ø§Ø³Ù‡ Ø­Ø³Ø§Ø¨
  debitAmount: number;     // Ù…Ø¨Ù„Øº Ø¨Ø¯Ù‡Ú©Ø§Ø±
  creditAmount: number;    // Ù…Ø¨Ù„Øº Ø¨Ø³ØªØ§Ù†Ú©Ø§Ø±
  description?: string;    // Ø´Ø±Ø­ Ø³Ø·Ø±
  lineOrder: number;       // ØªØ±ØªÛŒØ¨ Ø³Ø·Ø±
  costCenterId?: string;   // Ù…Ø±Ú©Ø² Ù‡Ø²ÛŒÙ†Ù‡
  projectId?: string;      // Ù¾Ø±ÙˆÚ˜Ù‡
}
```

### **Ù‚ÙˆØ§Ù†ÛŒÙ† Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ Ø¯ÙˆØ·Ø±ÙÙ‡**

```typescript
class JournalEntryValidator {
  static validateEntry(entry: JournalEntry): ValidationResult {
    const errors: string[] = [];
    
    // 1. ØªØ¹Ø§Ø¯Ù„ Ø¨Ø¯Ù‡Ú©Ø§Ø± Ùˆ Ø¨Ø³ØªØ§Ù†Ú©Ø§Ø±
    const totalDebit = entry.lines.reduce((sum, line) => sum + line.debitAmount, 0);
    const totalCredit = entry.lines.reduce((sum, line) => sum + line.creditAmount, 0);
    
    if (Math.abs(totalDebit - totalCredit) > 0.01) {
      errors.push('Ù…Ø¬Ù…ÙˆØ¹ Ø¨Ø¯Ù‡Ú©Ø§Ø± Ùˆ Ø¨Ø³ØªØ§Ù†Ú©Ø§Ø± Ø¨Ø§ÛŒØ¯ Ø¨Ø±Ø§Ø¨Ø± Ø¨Ø§Ø´Ø¯');
    }
    
    // 2. Ø­Ø¯Ø§Ù‚Ù„ Ø¯Ùˆ Ø³Ø·Ø±
    if (entry.lines.length < 2) {
      errors.push('Ø³Ù†Ø¯ Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ Ø¯Ùˆ Ø³Ø·Ø± Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯');
    }
    
    // 3. Ù‡Ø± Ø³Ø·Ø± Ø¨Ø§ÛŒØ¯ ÛŒØ§ Ø¨Ø¯Ù‡Ú©Ø§Ø± ÛŒØ§ Ø¨Ø³ØªØ§Ù†Ú©Ø§Ø± Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯
    for (const line of entry.lines) {
      if (line.debitAmount === 0 && line.creditAmount === 0) {
        errors.push('Ù‡Ø± Ø³Ø·Ø± Ø¨Ø§ÛŒØ¯ Ù…Ø¨Ù„Øº Ø¨Ø¯Ù‡Ú©Ø§Ø± ÛŒØ§ Ø¨Ø³ØªØ§Ù†Ú©Ø§Ø± Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯');
      }
      if (line.debitAmount > 0 && line.creditAmount > 0) {
        errors.push('Ù‡Ø± Ø³Ø·Ø± Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ù‡Ù… Ø¨Ø¯Ù‡Ú©Ø§Ø± Ùˆ Ù‡Ù… Ø¨Ø³ØªØ§Ù†Ú©Ø§Ø± Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯');
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
}
```

### **ØªÙˆÙ„ÛŒØ¯ Ø®ÙˆØ¯Ú©Ø§Ø± Ø§Ø³Ù†Ø§Ø¯**

```typescript
class AutoJournalGenerator {
  // Ø³Ù†Ø¯ Ø®Ø±ÛŒØ¯ Ú©Ø§Ù„Ø§
  static async generatePurchaseEntry(purchase: InventoryEntry): Promise<JournalEntry> {
    const totalAmount = purchase.quantity * purchase.unitPrice;
    
    return {
      entryDate: purchase.date,
      reference: `INV-${purchase.id}`,
      description: `Ø®Ø±ÛŒØ¯ Ú©Ø§Ù„Ø§: ${purchase.item.name}`,
      lines: [
        {
          accountId: 'inventory-account',  // Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©Ø§Ù„Ø§
          debitAmount: totalAmount,
          creditAmount: 0,
          description: `Ø®Ø±ÛŒØ¯ ${purchase.quantity} ÙˆØ§Ø­Ø¯ ${purchase.item.name}`
        },
        {
          accountId: 'accounts-payable',   // Ø­Ø³Ø§Ø¨â€ŒÙ‡Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®ØªÙ†ÛŒ
          debitAmount: 0,
          creditAmount: totalAmount,
          description: `Ø¨Ø¯Ù‡ÛŒ Ø¨Ù‡ ØªØ£Ù…ÛŒÙ†â€ŒÚ©Ù†Ù†Ø¯Ù‡: ${purchase.supplier?.name}`
        }
      ]
    };
  }
  
  // Ø³Ù†Ø¯ ÙØ±ÙˆØ´ Ú©Ø§Ù„Ø§ (Ø§Ø² POS)
  static async generateSaleEntry(sale: POSTransaction): Promise<JournalEntry> {
    const entries: JournalEntryLine[] = [];
    
    // Ø¯Ø±Ø¢Ù…Ø¯ ÙØ±ÙˆØ´
    entries.push({
      accountId: 'cash-account',        // ØµÙ†Ø¯ÙˆÙ‚
      debitAmount: sale.totalAmount,
      creditAmount: 0,
      description: 'Ø¯Ø±ÛŒØ§ÙØª ÙˆØ¬Ù‡ Ù†Ù‚Ø¯ Ø§Ø² ÙØ±ÙˆØ´'
    });
    
    entries.push({
      accountId: 'sales-revenue',       // Ø¯Ø±Ø¢Ù…Ø¯ ÙØ±ÙˆØ´
      debitAmount: 0,
      creditAmount: sale.totalAmount,
      description: 'Ø¯Ø±Ø¢Ù…Ø¯ Ø­Ø§ØµÙ„ Ø§Ø² ÙØ±ÙˆØ´ Ú©Ø§Ù„Ø§'
    });
    
    // Ø¨Ù‡Ø§ÛŒ ØªÙ…Ø§Ù… Ø´Ø¯Ù‡ (Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ø¢ÛŒØªÙ…)
    for (const item of sale.items) {
      const costPrice = await this.getItemCostPrice(item.itemId);
      const totalCost = item.quantity * costPrice;
      
      entries.push({
        accountId: 'cost-of-goods-sold', // Ø¨Ù‡Ø§ÛŒ ØªÙ…Ø§Ù… Ø´Ø¯Ù‡
        debitAmount: totalCost,
        creditAmount: 0,
        description: `Ø¨Ù‡Ø§ÛŒ ØªÙ…Ø§Ù… Ø´Ø¯Ù‡: ${item.itemName}`
      });
      
      entries.push({
        accountId: 'inventory-account',  // Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©Ø§Ù„Ø§
        debitAmount: 0,
        creditAmount: totalCost,
        description: `Ú©Ø§Ù‡Ø´ Ù…ÙˆØ¬ÙˆØ¯ÛŒ: ${item.itemName}`
      });
    }
    
    return {
      entryDate: sale.transactionAt,
      reference: `POS-${sale.externalTransactionId}`,
      description: `ÙØ±ÙˆØ´ Ù†Ù‚Ø¯ÛŒ - Ø±Ø³ÛŒØ¯ Ø´Ù…Ø§Ø±Ù‡: ${sale.receiptNumber}`,
      lines: entries
    };
  }
  
  // Ø³Ù†Ø¯ Ù¾Ø±Ø¯Ø§Ø®Øª Ø­Ù‚ÙˆÙ‚
  static async generatePayrollEntry(payroll: PayrollData): Promise<JournalEntry> {
    return {
      entryDate: payroll.payDate,
      reference: `PAY-${payroll.id}`,
      description: `Ù¾Ø±Ø¯Ø§Ø®Øª Ø­Ù‚ÙˆÙ‚ ${payroll.period}`,
      lines: [
        {
          accountId: 'salary-expense',    // Ù‡Ø²ÛŒÙ†Ù‡ Ø­Ù‚ÙˆÙ‚
          debitAmount: payroll.grossAmount,
          creditAmount: 0,
          description: 'Ù‡Ø²ÛŒÙ†Ù‡ Ø­Ù‚ÙˆÙ‚ Ùˆ Ø¯Ø³ØªÙ…Ø²Ø¯'
        },
        {
          accountId: 'tax-payable',       // Ù…Ø§Ù„ÛŒØ§Øª Ù¾Ø±Ø¯Ø§Ø®ØªÙ†ÛŒ
          debitAmount: 0,
          creditAmount: payroll.taxAmount,
          description: 'Ù…Ø§Ù„ÛŒØ§Øª Ø­Ù‚ÙˆÙ‚'
        },
        {
          accountId: 'cash-account',      // ØµÙ†Ø¯ÙˆÙ‚
          debitAmount: 0,
          creditAmount: payroll.netAmount,
          description: 'Ù¾Ø±Ø¯Ø§Ø®Øª Ø­Ù‚ÙˆÙ‚ Ø®Ø§Ù„Øµ'
        }
      ]
    };
  }
}
```

---

## ğŸ¢ **Cost Centers (Ù…Ø±Ø§Ú©Ø² Ù‡Ø²ÛŒÙ†Ù‡)**

### **Ø³Ø§Ø®ØªØ§Ø± Ù…Ø±Ø§Ú©Ø² Ù‡Ø²ÛŒÙ†Ù‡**

```typescript
interface CostCenter {
  id: string;
  code: string;             // Ú©Ø¯ Ù…Ø±Ú©Ø² Ù‡Ø²ÛŒÙ†Ù‡
  name: string;             // Ù†Ø§Ù… Ù…Ø±Ú©Ø²
  description?: string;
  parentCostCenterId?: string;
  level: number;
  isActive: boolean;
  managerId?: string;       // Ù…Ø¯ÛŒØ± Ù…Ø±Ú©Ø²
  budgetAllocated: number;  // Ø¨ÙˆØ¯Ø¬Ù‡ ØªØ®ØµÛŒØµ ÛŒØ§ÙØªÙ‡
  actualSpent: number;      // Ù‡Ø²ÛŒÙ†Ù‡ ÙˆØ§Ù‚Ø¹ÛŒ
  children?: CostCenter[];
  createdAt: Date;
  updatedAt: Date;
}

// Ù…Ø«Ø§Ù„ Ø³Ø§Ø®ØªØ§Ø± Ù…Ø±Ø§Ú©Ø² Ù‡Ø²ÛŒÙ†Ù‡ Ø¨Ø±Ø§ÛŒ Ú©Ø§ÙÙ‡
const costCentersStructure = {
  "CC001": {
    "name": "Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ù„",
    "level": 1,
    "children": {
      "CC001-01": "Ù…Ø¯ÛŒØ± Ø¹Ø§Ù…Ù„",
      "CC001-02": "Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ",
      "CC001-03": "Ù…Ù†Ø§Ø¨Ø¹ Ø§Ù†Ø³Ø§Ù†ÛŒ"
    }
  },
  "CC002": {
    "name": "ØªÙˆÙ„ÛŒØ¯ Ùˆ Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ",
    "level": 1,
    "children": {
      "CC002-01": "Ø¢Ø´Ù¾Ø²Ø®Ø§Ù†Ù‡",
      "CC002-02": "Ù‚Ù‡ÙˆÙ‡â€ŒØ³Ø§Ø²ÛŒ",
      "CC002-03": "Ø´ÛŒØ±ÛŒÙ†ÛŒâ€ŒØ³Ø§Ø²ÛŒ"
    }
  },
  "CC003": {
    "name": "ÙØ±ÙˆØ´ Ùˆ Ø®Ø¯Ù…Ø§Øª",
    "level": 1,
    "children": {
      "CC003-01": "Ø³Ø§Ù„Ù† Ù¾Ø°ÛŒØ±Ø§ÛŒÛŒ",
      "CC003-02": "Ø³Ø±Ùˆ Ùˆ ØµÙ†Ø¯ÙˆÙ‚",
      "CC003-03": "ØªØ­ÙˆÛŒÙ„ Ø¨ÛŒØ±ÙˆÙ† Ø¨Ø±"
    }
  },
  "CC004": {
    "name": "Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ",
    "level": 1,
    "children": {
      "CC004-01": "Ù†Ø¸Ø§ÙØª",
      "CC004-02": "Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒ",
      "CC004-03": "Ø§Ù…Ù†ÛŒØª"
    }
  }
};
```

### **ØªØ­Ù„ÛŒÙ„ Ù‡Ø²ÛŒÙ†Ù‡ Ø¨Ù‡ ØªÙÚ©ÛŒÚ© Ù…Ø±Ú©Ø²**

```typescript
class CostCenterAnalytics {
  async getCostCenterPerformance(
    costCenterId: string, 
    period: { from: Date; to: Date }
  ): Promise<CostCenterPerformance> {
    
    const transactions = await this.getTransactionsByCostCenter(costCenterId, period);
    
    const analysis = {
      costCenterId,
      period,
      budgetAllocated: 0,
      actualSpent: 0,
      variance: 0,
      variancePercent: 0,
      expenseCategories: {},
      monthlyTrend: [],
      topExpenses: [],
      efficiency: 0
    };
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‡Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ
    analysis.actualSpent = transactions.reduce((sum, t) => sum + t.amount, 0);
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø­Ø±Ø§Ù Ø§Ø² Ø¨ÙˆØ¯Ø¬Ù‡
    const budget = await this.getCostCenterBudget(costCenterId, period);
    analysis.budgetAllocated = budget.amount;
    analysis.variance = analysis.actualSpent - analysis.budgetAllocated;
    analysis.variancePercent = (analysis.variance / analysis.budgetAllocated) * 100;
    
    // ØªØ­Ù„ÛŒÙ„ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù‡Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§
    analysis.expenseCategories = this.categorizeExpenses(transactions);
    
    // Ø±ÙˆÙ†Ø¯ Ù…Ø§Ù‡Ø§Ù†Ù‡
    analysis.monthlyTrend = await this.getMonthlyTrend(costCenterId, period);
    
    // Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ù‡Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§
    analysis.topExpenses = this.getTopExpenses(transactions);
    
    return analysis;
  }
  
  async allocateExpenseToCostCenters(
    expense: JournalEntry,
    allocationMethod: 'EQUAL' | 'WEIGHTED' | 'CUSTOM',
    allocation?: { [costCenterId: string]: number }
  ): Promise<void> {
    
    const costCenters = await this.getActiveCostCenters();
    let allocationMap: { [costCenterId: string]: number } = {};
    
    switch (allocationMethod) {
      case 'EQUAL':
        const equalShare = expense.totalAmount / costCenters.length;
        costCenters.forEach(cc => {
          allocationMap[cc.id] = equalShare;
        });
        break;
        
      case 'WEIGHTED':
        // ØªØ®ØµÛŒØµ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¯Ø±Ø¢Ù…Ø¯ Ù‡Ø± Ù…Ø±Ú©Ø²
        const revenues = await this.getCostCenterRevenues(costCenters);
        const totalRevenue = Object.values(revenues).reduce((sum, r) => sum + r, 0);
        
        costCenters.forEach(cc => {
          const weight = revenues[cc.id] / totalRevenue;
          allocationMap[cc.id] = expense.totalAmount * weight;
        });
        break;
        
      case 'CUSTOM':
        allocationMap = allocation || {};
        break;
    }
    
    // Ø§ÛŒØ¬Ø§Ø¯ Ø³Ø·ÙˆØ± Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ø³Ù†Ø¯
    for (const [costCenterId, amount] of Object.entries(allocationMap)) {
      await this.addCostCenterLine(expense.id, costCenterId, amount);
    }
  }
}
```

---

## ğŸ“ˆ **ØªØ­Ù„ÛŒÙ„ Ø³ÙˆØ¯Ø¢ÙˆØ±ÛŒ**

### **Ø³ÙˆØ¯Ø¢ÙˆØ±ÛŒ Ø¨Ù‡ ØªÙÚ©ÛŒÚ© Ú©Ø§Ù„Ø§**

```typescript
interface ItemProfitability {
  itemId: string;
  itemName: string;
  category: string;
  period: { from: Date; to: Date };
  
  // ÙØ±ÙˆØ´
  totalSales: number;
  salesQuantity: number;
  averageSalePrice: number;
  
  // Ù‡Ø²ÛŒÙ†Ù‡
  totalCost: number;
  averageCostPrice: number;
  
  // Ø³ÙˆØ¯Ø¢ÙˆØ±ÛŒ
  grossProfit: number;
  grossProfitMargin: number;    // Ø¯Ø±ØµØ¯
  profitPerUnit: number;
  
  // Ù…Ù‚Ø§ÛŒØ³Ù‡ Ø¨Ø§ Ø¯ÙˆØ±Ù‡ Ù‚Ø¨Ù„
  salesGrowth: number;          // Ø¯Ø±ØµØ¯ Ø±Ø´Ø¯ ÙØ±ÙˆØ´
  marginTrend: 'IMPROVING' | 'DECLINING' | 'STABLE';
  
  // Ø±ØªØ¨Ù‡â€ŒØ¨Ù†Ø¯ÛŒ
  profitabilityRank: number;    // Ø±ØªØ¨Ù‡ Ø¯Ø± Ø¨ÛŒÙ† Ú©Ø§Ù„Ø§Ù‡Ø§
  salesVolumeRank: number;      // Ø±ØªØ¨Ù‡ Ø­Ø¬Ù… ÙØ±ÙˆØ´
}

class ProfitabilityAnalyzer {
  async analyzeItemProfitability(
    itemId: string, 
    period: { from: Date; to: Date }
  ): Promise<ItemProfitability> {
    
    // Ø¯Ø±ÛŒØ§ÙØª ÙØ±ÙˆØ´ Ø§Ø² POS
    const salesData = await this.getPOSSalesForItem(itemId, period);
    const totalSales = salesData.reduce((sum, sale) => sum + sale.totalPrice, 0);
    const salesQuantity = salesData.reduce((sum, sale) => sum + sale.quantity, 0);
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ù‡Ø§ÛŒ ØªÙ…Ø§Ù… Ø´Ø¯Ù‡
    const costData = await this.getItemCostAnalysis(itemId, period);
    const averageCostPrice = costData.weightedAverageCost;
    const totalCost = salesQuantity * averageCostPrice;
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³ÙˆØ¯
    const grossProfit = totalSales - totalCost;
    const grossProfitMargin = (grossProfit / totalSales) * 100;
    const profitPerUnit = grossProfit / salesQuantity;
    
    // Ù…Ù‚Ø§ÛŒØ³Ù‡ Ø¨Ø§ Ø¯ÙˆØ±Ù‡ Ù‚Ø¨Ù„
    const previousPeriod = this.getPreviousPeriod(period);
    const previousAnalysis = await this.analyzeItemProfitability(itemId, previousPeriod);
    const salesGrowth = ((totalSales - previousAnalysis.totalSales) / previousAnalysis.totalSales) * 100;
    
    return {
      itemId,
      itemName: (await this.getItem(itemId)).name,
      category: (await this.getItem(itemId)).category.name,
      period,
      totalSales,
      salesQuantity,
      averageSalePrice: totalSales / salesQuantity,
      totalCost,
      averageCostPrice,
      grossProfit,
      grossProfitMargin,
      profitPerUnit,
      salesGrowth,
      marginTrend: this.determineMarginTrend(grossProfitMargin, previousAnalysis.grossProfitMargin),
      profitabilityRank: 0, // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ø¹Ø¯Ø§Ù‹
      salesVolumeRank: 0    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ø¹Ø¯Ø§Ù‹
    };
  }
  
  async getTopProfitableItems(
    limit: number = 10,
    period: { from: Date; to: Date },
    sortBy: 'PROFIT_MARGIN' | 'TOTAL_PROFIT' | 'PROFIT_PER_UNIT' = 'TOTAL_PROFIT'
  ): Promise<ItemProfitability[]> {
    
    const allItems = await this.getAllActiveItems();
    const analyses = await Promise.all(
      allItems.map(item => this.analyzeItemProfitability(item.id, period))
    );
    
    // Ù…Ø±ØªØ¨â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù…Ø¹ÛŒØ§Ø± Ø§Ù†ØªØ®Ø§Ø¨ÛŒ
    const sorted = analyses.sort((a, b) => {
      switch (sortBy) {
        case 'PROFIT_MARGIN':
          return b.grossProfitMargin - a.grossProfitMargin;
        case 'TOTAL_PROFIT':
          return b.grossProfit - a.grossProfit;
        case 'PROFIT_PER_UNIT':
          return b.profitPerUnit - a.profitPerUnit;
        default:
          return b.grossProfit - a.grossProfit;
      }
    });
    
    // Ø§Ø®ØªØµØ§Øµ Ø±ØªØ¨Ù‡
    sorted.forEach((analysis, index) => {
      analysis.profitabilityRank = index + 1;
    });
    
    return sorted.slice(0, limit);
  }
  
  async analyzeCategoryProfitability(
    categoryId: string,
    period: { from: Date; to: Date }
  ): Promise<CategoryProfitability> {
    
    const categoryItems = await this.getItemsByCategory(categoryId);
    const itemAnalyses = await Promise.all(
      categoryItems.map(item => this.analyzeItemProfitability(item.id, period))
    );
    
    const totalSales = itemAnalyses.reduce((sum, analysis) => sum + analysis.totalSales, 0);
    const totalCost = itemAnalyses.reduce((sum, analysis) => sum + analysis.totalCost, 0);
    const grossProfit = totalSales - totalCost;
    const grossProfitMargin = (grossProfit / totalSales) * 100;
    
    return {
      categoryId,
      categoryName: (await this.getCategory(categoryId)).name,
      period,
      itemCount: categoryItems.length,
      totalSales,
      totalCost,
      grossProfit,
      grossProfitMargin,
      topItems: itemAnalyses
        .sort((a, b) => b.grossProfit - a.grossProfit)
        .slice(0, 5),
      bottomItems: itemAnalyses
        .sort((a, b) => a.grossProfit - b.grossProfit)
        .slice(0, 3)
    };
  }
}
```

### **ABC Analysis (ØªØ­Ù„ÛŒÙ„ Ù¾Ø§Ø±ØªÙˆ)**

```typescript
class ABCAnalyzer {
  async performABCAnalysis(
    period: { from: Date; to: Date },
    criterion: 'SALES_VALUE' | 'PROFIT' | 'QUANTITY' = 'SALES_VALUE'
  ): Promise<ABCAnalysisResult> {
    
    const items = await this.getAllItemsWithSalesData(period);
    
    // Ù…Ø±ØªØ¨â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù…Ø¹ÛŒØ§Ø± Ø§Ù†ØªØ®Ø§Ø¨ÛŒ
    const sorted = items.sort((a, b) => {
      switch (criterion) {
        case 'SALES_VALUE':
          return b.totalSalesValue - a.totalSalesValue;
        case 'PROFIT':
          return b.totalProfit - a.totalProfit;
        case 'QUANTITY':
          return b.totalQuantitySold - a.totalQuantitySold;
        default:
          return b.totalSalesValue - a.totalSalesValue;
      }
    });
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¯Ø±ØµØ¯ ØªØ¬Ù…Ø¹ÛŒ
    const totalValue = sorted.reduce((sum, item) => {
      switch (criterion) {
        case 'SALES_VALUE':
          return sum + item.totalSalesValue;
        case 'PROFIT':
          return sum + item.totalProfit;
        case 'QUANTITY':
          return sum + item.totalQuantitySold;
        default:
          return sum + item.totalSalesValue;
      }
    }, 0);
    
    let cumulativeValue = 0;
    const classified = sorted.map(item => {
      const itemValue = this.getItemValue(item, criterion);
      cumulativeValue += itemValue;
      const cumulativePercent = (cumulativeValue / totalValue) * 100;
      
      let category: 'A' | 'B' | 'C';
      if (cumulativePercent <= 80) {
        category = 'A';  // 80% Ø§Ø±Ø²Ø´ Ø¯Ø± 20% Ú©Ø§Ù„Ø§Ù‡Ø§
      } else if (cumulativePercent <= 95) {
        category = 'B';  // 15% Ø§Ø±Ø²Ø´ Ø¯Ø± 30% Ú©Ø§Ù„Ø§Ù‡Ø§
      } else {
        category = 'C';  // 5% Ø§Ø±Ø²Ø´ Ø¯Ø± 50% Ú©Ø§Ù„Ø§Ù‡Ø§
      }
      
      return {
        ...item,
        abcCategory: category,
        cumulativePercent,
        valuePercent: (itemValue / totalValue) * 100
      };
    });
    
    // Ø®Ù„Ø§ØµÙ‡ ØªØ­Ù„ÛŒÙ„
    const summary = {
      totalItems: sorted.length,
      categoryA: {
        itemCount: classified.filter(i => i.abcCategory === 'A').length,
        valuePercent: 80,
        items: classified.filter(i => i.abcCategory === 'A')
      },
      categoryB: {
        itemCount: classified.filter(i => i.abcCategory === 'B').length,
        valuePercent: 15,
        items: classified.filter(i => i.abcCategory === 'B')
      },
      categoryC: {
        itemCount: classified.filter(i => i.abcCategory === 'C').length,
        valuePercent: 5,
        items: classified.filter(i => i.abcCategory === 'C')
      }
    };
    
    return {
      period,
      criterion,
      items: classified,
      summary,
      recommendations: this.generateABCRecommendations(summary)
    };
  }
  
  generateABCRecommendations(summary: ABCSummary): string[] {
    const recommendations = [];
    
    // ØªÙˆØµÛŒÙ‡â€ŒÙ‡Ø§ÛŒ Ú©Ù„Ø§Ø³ A
    if (summary.categoryA.itemCount > 0) {
      recommendations.push(
        `Ú©Ø§Ù„Ø§Ù‡Ø§ÛŒ Ú©Ù„Ø§Ø³ A (${summary.categoryA.itemCount} Ù‚Ù„Ù…): Ù†ÛŒØ§Ø² Ø¨Ù‡ Ù†Ø¸Ø§Ø±Øª Ø¯Ù‚ÛŒÙ‚ Ø±ÙˆØ²Ø§Ù†Ù‡ØŒ Ú©Ù†ØªØ±Ù„ Ù…ÙˆØ¬ÙˆØ¯ÛŒ ÙˆÛŒÚ˜Ù‡ØŒ Ùˆ ØªØ§Ù…ÛŒÙ†â€ŒÚ©Ù†Ù†Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù‚Ø§Ø¨Ù„ Ø§Ø¹ØªÙ…Ø§Ø¯`
      );
    }
    
    // ØªÙˆØµÛŒÙ‡â€ŒÙ‡Ø§ÛŒ Ú©Ù„Ø§Ø³ B
    if (summary.categoryB.itemCount > 0) {
      recommendations.push(
        `Ú©Ø§Ù„Ø§Ù‡Ø§ÛŒ Ú©Ù„Ø§Ø³ B (${summary.categoryB.itemCount} Ù‚Ù„Ù…): Ù†Ø¸Ø§Ø±Øª Ù‡ÙØªÚ¯ÛŒØŒ Ø³ÛŒØ³ØªÙ… Ø³ÙØ§Ø±Ø´â€ŒØ¯Ù‡ÛŒ Ù…Ø¹Ù…ÙˆÙ„ÛŒØŒ Ùˆ Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø§Ù‡Ø§Ù†Ù‡ Ø¹Ù…Ù„Ú©Ø±Ø¯`
      );
    }
    
    // ØªÙˆØµÛŒÙ‡â€ŒÙ‡Ø§ÛŒ Ú©Ù„Ø§Ø³ C
    if (summary.categoryC.itemCount > 0) {
      recommendations.push(
        `Ú©Ø§Ù„Ø§Ù‡Ø§ÛŒ Ú©Ù„Ø§Ø³ C (${summary.categoryC.itemCount} Ù‚Ù„Ù…): Ø³ÙØ§Ø±Ø´â€ŒØ¯Ù‡ÛŒ ÙØµÙ„ÛŒØŒ Ø­Ø¯Ø§Ù‚Ù„ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø§ÛŒÙ…Ù†ÛŒØŒ Ùˆ Ø¨Ø±Ø±Ø³ÛŒ Ø§Ù…Ú©Ø§Ù† Ø­Ø°Ù Ú©Ø§Ù„Ø§Ù‡Ø§ÛŒ Ú©Ù…â€ŒÙØ±ÙˆØ´`
      );
    }
    
    return recommendations;
  }
}
```

---

## ğŸ“Š **Financial Statements (ØµÙˆØ±Øªâ€ŒÙ‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ)**

### **Balance Sheet (ØªØ±Ø§Ø²Ù†Ø§Ù…Ù‡)**

```typescript
class BalanceSheetGenerator {
  async generateBalanceSheet(
    asOfDate: Date,
    comparative: boolean = false
  ): Promise<BalanceSheet> {
    
    const balanceSheet: BalanceSheet = {
      asOfDate,
      assets: {
        currentAssets: await this.getCurrentAssets(asOfDate),
        fixedAssets: await this.getFixedAssets(asOfDate),
        totalAssets: 0
      },
      liabilities: {
        currentLiabilities: await this.getCurrentLiabilities(asOfDate),
        longTermLiabilities: await this.getLongTermLiabilities(asOfDate),
        totalLiabilities: 0
      },
      equity: {
        paidInCapital: await this.getPaidInCapital(asOfDate),
        retainedEarnings: await this.getRetainedEarnings(asOfDate),
        totalEquity: 0
      },
      totalLiabilitiesAndEquity: 0
    };
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø¬Ø§Ù…ÙŠØ¹
    balanceSheet.assets.totalAssets = 
      balanceSheet.assets.currentAssets.total + 
      balanceSheet.assets.fixedAssets.total;
      
    balanceSheet.liabilities.totalLiabilities = 
      balanceSheet.liabilities.currentLiabilities.total + 
      balanceSheet.liabilities.longTermLiabilities.total;
      
    balanceSheet.equity.totalEquity = 
      balanceSheet.equity.paidInCapital + 
      balanceSheet.equity.retainedEarnings;
      
    balanceSheet.totalLiabilitiesAndEquity = 
      balanceSheet.liabilities.totalLiabilities + 
      balanceSheet.equity.totalEquity;
    
    // Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ ØªØ¹Ø§Ø¯Ù„
    const balanceDifference = Math.abs(
      balanceSheet.assets.totalAssets - 
      balanceSheet.totalLiabilitiesAndEquity
    );
    
    if (balanceDifference > 0.01) {
      throw new Error(`ØªØ±Ø§Ø²Ù†Ø§Ù…Ù‡ Ù…ØªØ¹Ø§Ø¯Ù„ Ù†ÛŒØ³Øª. Ø§Ø®ØªÙ„Ø§Ù: ${balanceDifference}`);
    }
    
    // ØªØ±Ø§Ø²Ù†Ø§Ù…Ù‡ Ù…Ù‚Ø§ÛŒØ³Ù‡â€ŒØ§ÛŒ
    if (comparative) {
      const previousYearDate = new Date(asOfDate);
      previousYearDate.setFullYear(previousYearDate.getFullYear() - 1);
      
      balanceSheet.comparative = await this.generateBalanceSheet(
        previousYearDate, 
        false
      );
      
      balanceSheet.variances = this.calculateVariances(
        balanceSheet, 
        balanceSheet.comparative
      );
    }
    
    return balanceSheet;
  }
  
  private async getCurrentAssets(asOfDate: Date): Promise<AssetSection> {
    const accounts = await this.getAccountsByType('ASSET', ['1100']);
    const balances = await this.getAccountBalances(accounts, asOfDate);
    
    return {
      cash: balances['1101'] || 0,              // ØµÙ†Ø¯ÙˆÙ‚
      bankAccounts: balances['1102'] || 0,      // Ø¨Ø§Ù†Ú©
      accountsReceivable: balances['1103'] || 0, // Ø­Ø³Ø§Ø¨â€ŒÙ‡Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØªÙ†ÛŒ
      inventory: balances['1104'] || 0,          // Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©Ø§Ù„Ø§
      prepaidExpenses: balances['1105'] || 0,    // Ù¾ÛŒØ´â€ŒÙ¾Ø±Ø¯Ø§Ø®Øªâ€ŒÙ‡Ø§
      total: 0 // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¯Ø± Ø§Ù†ØªÙ‡Ø§
    };
  }
  
  private async getInventoryValuation(asOfDate: Date): Promise<number> {
    // Ø±ÙˆØ´ FIFO Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø²Ø´â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒ
    const items = await this.getAllActiveItems();
    let totalValue = 0;
    
    for (const item of items) {
      const currentQuantity = await this.getCurrentQuantity(item.id, asOfDate);
      const averageCost = await this.getWeightedAverageCost(item.id, asOfDate);
      totalValue += currentQuantity * averageCost;
    }
    
    return totalValue;
  }
}
```

### **Income Statement (ØµÙˆØ±Øª Ø³ÙˆØ¯ Ùˆ Ø²ÛŒØ§Ù†)**

```typescript
class IncomeStatementGenerator {
  async generateIncomeStatement(
    period: { from: Date; to: Date },
    comparative: boolean = false
  ): Promise<IncomeStatement> {
    
    const incomeStatement: IncomeStatement = {
      period,
      revenue: await this.getRevenue(period),
      costOfGoodsSold: await this.getCostOfGoodsSold(period),
      grossProfit: 0,
      operatingExpenses: await this.getOperatingExpenses(period),
      operatingIncome: 0,
      nonOperatingIncome: await this.getNonOperatingIncome(period),
      nonOperatingExpenses: await this.getNonOperatingExpenses(period),
      incomeBeforeTax: 0,
      incomeTaxExpense: await this.getIncomeTaxExpense(period),
      netIncome: 0
    };
    
    // Ù…Ø­Ø§Ø³Ø¨Ø§Øª
    incomeStatement.grossProfit = 
      incomeStatement.revenue.total - incomeStatement.costOfGoodsSold.total;
      
    incomeStatement.operatingIncome = 
      incomeStatement.grossProfit - incomeStatement.operatingExpenses.total;
      
    incomeStatement.incomeBeforeTax = 
      incomeStatement.operatingIncome + 
      incomeStatement.nonOperatingIncome.total - 
      incomeStatement.nonOperatingExpenses.total;
      
    incomeStatement.netIncome = 
      incomeStatement.incomeBeforeTax - incomeStatement.incomeTaxExpense;
    
    // ØµÙˆØ±Øª Ù…Ù‚Ø§ÛŒØ³Ù‡â€ŒØ§ÛŒ
    if (comparative) {
      const previousPeriod = this.getPreviousPeriod(period);
      incomeStatement.comparative = await this.generateIncomeStatement(
        previousPeriod, 
        false
      );
      
      incomeStatement.variances = this.calculateIncomeStatementVariances(
        incomeStatement, 
        incomeStatement.comparative
      );
    }
    
    return incomeStatement;
  }
  
  private async getRevenue(period: { from: Date; to: Date }): Promise<RevenueSection> {
    // Ø¯Ø±Ø¢Ù…Ø¯ Ø§Ø² ÙØ±ÙˆØ´ Ú©Ø§Ù„Ø§ (Ø§Ø² POS)
    const salesRevenue = await this.getPOSSalesRevenue(period);
    
    // Ø³Ø§ÛŒØ± Ø¯Ø±Ø¢Ù…Ø¯Ù‡Ø§
    const otherRevenue = await this.getAccountBalance('4102', period); // Ø¯Ø±Ø¢Ù…Ø¯Ù‡Ø§ÛŒ Ù…ØªÙØ±Ù‚Ù‡
    
    return {
      salesRevenue,
      otherRevenue,
      total: salesRevenue + otherRevenue
    };
  }
  
  private async getCostOfGoodsSold(period: { from: Date; to: Date }): Promise<COGSSection> {
    // Ø¨Ù‡Ø§ÛŒ ØªÙ…Ø§Ù… Ø´Ø¯Ù‡ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯Ù‡ Ø§Ø² ÙØ±ÙˆØ´ POS
    const directCosts = await this.calculateCOGSFromSales(period);
    
    // Ù‡Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ø³ØªÙ‚ÛŒÙ… Ø§Ø¶Ø§ÙÛŒ
    const additionalCosts = await this.getAccountBalance('5102', period); // Ø­Ù…Ù„ Ùˆ Ù†Ù‚Ù„ Ø®Ø±ÛŒØ¯
    
    return {
      beginningInventory: await this.getBeginningInventory(period.from),
      purchases: await this.getPurchases(period),
      endingInventory: await this.getEndingInventory(period.to),
      directLabor: await this.getDirectLaborCosts(period),
      manufacturingOverhead: await this.getManufacturingOverhead(period),
      total: directCosts + additionalCosts
    };
  }
  
  private async calculateCOGSFromSales(period: { from: Date; to: Date }): Promise<number> {
    const salesTransactions = await this.getPOSTransactions(period);
    let totalCOGS = 0;
    
    for (const sale of salesTransactions) {
      for (const item of sale.items) {
        // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±ÙˆØ´ FIFO Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ù‡Ø§ÛŒ ØªÙ…Ø§Ù… Ø´Ø¯Ù‡
        const avgCost = await this.getFIFOCostForSale(
          item.itemId, 
          item.quantity, 
          sale.transactionAt
        );
        totalCOGS += item.quantity * avgCost;
      }
    }
    
    return totalCOGS;
  }
}
```

---

## ğŸ’° **Budget Management (Ù…Ø¯ÛŒØ±ÛŒØª Ø¨ÙˆØ¯Ø¬Ù‡)**

### **Ø³Ø§Ø®ØªØ§Ø± Ø¨ÙˆØ¯Ø¬Ù‡**

```typescript
interface Budget {
  id: string;
  name: string;
  fiscalYear: number;
  startDate: Date;
  endDate: Date;
  status: 'DRAFT' | 'APPROVED' | 'ACTIVE' | 'CLOSED';
  totalBudget: number;
  description?: string;
  lines: BudgetLine[];
  createdBy: string;
  approvedBy?: string;
  approvedAt?: Date;
  variance?: BudgetVariance;
}

interface BudgetLine {
  id: string;
  accountId: string;
  categoryId?: string;
  costCenterId?: string;
  plannedAmount: number;
  actualAmount: number;
  variance: number;
  variancePercent: number;
  notes?: string;
  monthlyAllocation: MonthlyBudget[];
}

interface MonthlyBudget {
  month: number;
  plannedAmount: number;
  actualAmount: number;
  variance: number;
}
```

### **Budget Planning Engine**

```typescript
class BudgetPlanningEngine {
  async createAnnualBudget(
    fiscalYear: number,
    basedOn: 'HISTORICAL' | 'ZERO_BASED' | 'INCREMENTAL' = 'HISTORICAL'
  ): Promise<Budget> {
    
    const budget: Budget = {
      name: `Ø¨ÙˆØ¯Ø¬Ù‡ Ø³Ø§Ù„ ${fiscalYear}`,
      fiscalYear,
      startDate: new Date(fiscalYear, 0, 1),  // 1 ÙØ±ÙˆØ±Ø¯ÛŒÙ†
      endDate: new Date(fiscalYear, 11, 29),  // 29 Ø§Ø³ÙÙ†Ø¯
      status: 'DRAFT',
      totalBudget: 0,
      lines: []
    };
    
    switch (basedOn) {
      case 'HISTORICAL':
        budget.lines = await this.createHistoricalBasedBudget(fiscalYear);
        break;
      case 'ZERO_BASED':
        budget.lines = await this.createZeroBasedBudget(fiscalYear);
        break;
      case 'INCREMENTAL':
        budget.lines = await this.createIncrementalBudget(fiscalYear);
        break;
    }
    
    budget.totalBudget = budget.lines.reduce((sum, line) => sum + line.plannedAmount, 0);
    
    return budget;
  }
  
  private async createHistoricalBasedBudget(fiscalYear: number): Promise<BudgetLine[]> {
    const previousYear = fiscalYear - 1;
    const previousYearData = await this.getHistoricalData(previousYear);
    const growthRate = await this.calculateGrowthRate(previousYear);
    
    const budgetLines: BudgetLine[] = [];
    
    for (const account of await this.getBudgetableAccounts()) {
      const historicalAmount = previousYearData[account.id] || 0;
      const projectedAmount = historicalAmount * (1 + growthRate);
      
      budgetLines.push({
        accountId: account.id,
        plannedAmount: projectedAmount,
        actualAmount: 0,
        variance: 0,
        variancePercent: 0,
        monthlyAllocation: this.distributeMonthly(projectedAmount, account.seasonality)
      });
    }
    
    return budgetLines;
  }
  
  async performVarianceAnalysis(
    budgetId: string,
    period: { from: Date; to: Date }
  ): Promise<BudgetVarianceAnalysis> {
    
    const budget = await this.getBudget(budgetId);
    const actualData = await this.getActualSpending(budget.lines, period);
    
    const analysis: BudgetVarianceAnalysis = {
      budgetId,
      period,
      totalBudgeted: 0,
      totalActual: 0,
      totalVariance: 0,
      totalVariancePercent: 0,
      lines: [],
      significantVariances: [],
      recommendations: []
    };
    
    for (const budgetLine of budget.lines) {
      const actual = actualData[budgetLine.accountId] || 0;
      const variance = actual - budgetLine.plannedAmount;
      const variancePercent = (variance / budgetLine.plannedAmount) * 100;
      
      const lineAnalysis = {
        accountId: budgetLine.accountId,
        accountName: (await this.getAccount(budgetLine.accountId)).accountName,
        budgeted: budgetLine.plannedAmount,
        actual,
        variance,
        variancePercent,
        significance: this.determineSignificance(Math.abs(variancePercent)),
        explanation: await this.generateVarianceExplanation(budgetLine.accountId, variance)
      };
      
      analysis.lines.push(lineAnalysis);
      
      // Ø§Ù†Ø­Ø±Ø§ÙØ§Øª Ù…Ù‡Ù… (Ø¨ÛŒØ´ Ø§Ø² 10%)
      if (Math.abs(variancePercent) > 10) {
        analysis.significantVariances.push(lineAnalysis);
      }
    }
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø¬Ø§Ù…ÛŒØ¹
    analysis.totalBudgeted = analysis.lines.reduce((sum, line) => sum + line.budgeted, 0);
    analysis.totalActual = analysis.lines.reduce((sum, line) => sum + line.actual, 0);
    analysis.totalVariance = analysis.totalActual - analysis.totalBudgeted;
    analysis.totalVariancePercent = (analysis.totalVariance / analysis.totalBudgeted) * 100;
    
    // ØªÙˆÙ„ÛŒØ¯ ØªÙˆØµÛŒÙ‡â€ŒÙ‡Ø§
    analysis.recommendations = this.generateBudgetRecommendations(analysis);
    
    return analysis;
  }
  
  private generateBudgetRecommendations(analysis: BudgetVarianceAnalysis): string[] {
    const recommendations = [];
    
    // ØªÙˆØµÛŒÙ‡â€ŒÙ‡Ø§ÛŒ Ú©Ù„ÛŒ
    if (analysis.totalVariancePercent > 10) {
      recommendations.push('Ø¨Ø§Ø²Ù†Ú¯Ø±ÛŒ Ú©Ù„ÛŒ Ø¨ÙˆØ¯Ø¬Ù‡ Ø¶Ø±ÙˆØ±ÛŒ Ø§Ø³Øª. Ø§Ù†Ø­Ø±Ø§Ù Ú©Ù„ Ø§Ø² 10% ÙØ±Ø§ØªØ± Ø±ÙØªÙ‡ Ø§Ø³Øª.');
    }
    
    // ØªÙˆØµÛŒÙ‡â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØµÙˆØµ Ø§Ù†Ø­Ø±Ø§ÙØ§Øª Ù…Ù‡Ù…
    for (const variance of analysis.significantVariances) {
      if (variance.variance > 0) {
        recommendations.push(
          `Ù‡Ø²ÛŒÙ†Ù‡ ${variance.accountName} ${variance.variancePercent.toFixed(1)}% Ø¨ÛŒØ´ Ø§Ø² Ø¨ÙˆØ¯Ø¬Ù‡. Ø¨Ø±Ø±Ø³ÛŒ Ø¹Ù„Øª Ùˆ Ø§Ù‚Ø¯Ø§Ù… Ú©Ù†ØªØ±Ù„ÛŒ Ø¶Ø±ÙˆØ±ÛŒ.`
        );
      } else {
        recommendations.push(
          `Ù‡Ø²ÛŒÙ†Ù‡ ${variance.accountName} ${Math.abs(variance.variancePercent).toFixed(1)}% Ú©Ù…ØªØ± Ø§Ø² Ø¨ÙˆØ¯Ø¬Ù‡. Ø§Ù…Ú©Ø§Ù† Ø¨Ø§Ø²ØªØ®ØµÛŒØµ Ø¨ÙˆØ¯Ø¬Ù‡ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯.`
        );
      }
    }
    
    return recommendations;
  }
}
```

---

## ğŸ”„ **Integration with Existing System**

### **ÛŒÚ©Ù¾Ø§Ø±Ú†Ú¯ÛŒ Ø¨Ø§ Ø³ÛŒØ³ØªÙ… Ù…ÙˆØ¬ÙˆØ¯ÛŒ**

```typescript
class InventoryAccountingIntegration {
  async onInventoryTransaction(transaction: InventoryEntry): Promise<void> {
    let journalEntry: JournalEntry;
    
    switch (transaction.type) {
      case 'IN':
        journalEntry = await AutoJournalGenerator.generatePurchaseEntry(transaction);
        break;
      case 'OUT':
        // Ø§Ú¯Ø± Ø§Ø² POS Ù†ÛŒØ³ØªØŒ Ø³Ù†Ø¯ Ø¯Ø³ØªÛŒ Ø®Ø±ÙˆØ¬
        if (!transaction.posTransactionId) {
          journalEntry = await this.generateManualOutEntry(transaction);
        }
        break;
      case 'ADJUSTMENT':
        journalEntry = await this.generateAdjustmentEntry(transaction);
        break;
    }
    
    if (journalEntry) {
      await this.postJournalEntry(journalEntry);
      await this.updateInventoryValuation(transaction.itemId);
    }
  }
  
  async updateInventoryValuation(itemId: string): Promise<void> {
    const currentQuantity = await this.getCurrentQuantity(itemId);
    const weightedAverageCost = await this.calculateWeightedAverageCost(itemId);
    const totalValue = currentQuantity * weightedAverageCost;
    
    // Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©Ø§Ù„Ø§
    await this.updateAccountBalance('1104', totalValue);
  }
  
  private async calculateWeightedAverageCost(itemId: string): Promise<number> {
    const purchases = await this.getItemPurchases(itemId);
    
    let totalCost = 0;
    let totalQuantity = 0;
    
    for (const purchase of purchases) {
      totalCost += purchase.quantity * purchase.unitPrice;
      totalQuantity += purchase.quantity;
    }
    
    return totalQuantity > 0 ? totalCost / totalQuantity : 0;
  }
}
```

### **ÛŒÚ©Ù¾Ø§Ø±Ú†Ú¯ÛŒ Ø¨Ø§ POS**

```typescript
class POSAccountingIntegration {
  async onPOSTransaction(transaction: POSTransaction): Promise<void> {
    // Ø§ÛŒØ¬Ø§Ø¯ Ø³Ù†Ø¯ ÙØ±ÙˆØ´
    const salesEntry = await AutoJournalGenerator.generateSaleEntry(transaction);
    await this.postJournalEntry(salesEntry);
    
    // Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ø¢ÛŒØªÙ…
    for (const item of transaction.items) {
      if (item.itemId) {
        await this.reduceInventory(item.itemId, item.quantity);
        await this.updateInventoryValuation(item.itemId);
      }
    }
    
    // Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¢Ù…Ø§Ø± ÙØ±ÙˆØ´
    await this.updateSalesStatistics(transaction);
  }
  
  async reconcileDailySales(date: Date): Promise<DailyReconciliation> {
    const posTransactions = await this.getPOSTransactionsForDate(date);
    const journalEntries = await this.getJournalEntriesForDate(date, 'SALES');
    
    const posTotal = posTransactions.reduce((sum, t) => sum + t.totalAmount, 0);
    const journalTotal = journalEntries.reduce((sum, e) => sum + e.totalAmount, 0);
    
    const reconciliation: DailyReconciliation = {
      date,
      posTotal,
      journalTotal,
      difference: posTotal - journalTotal,
      reconciled: Math.abs(posTotal - journalTotal) < 0.01,
      discrepancies: []
    };
    
    if (!reconciliation.reconciled) {
      reconciliation.discrepancies = await this.findDiscrepancies(
        posTransactions, 
        journalEntries
      );
    }
    
    return reconciliation;
  }
}
```

**ğŸ¯ Ø³ÛŒØ³ØªÙ… Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ Ú©Ø§Ù…Ù„ Ø¢Ù…Ø§Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø§Ø³Øª! ØªÙ…Ø§Ù… Ø¬Ø²Ø¦ÛŒØ§Øª Ø·Ø±Ø§Ø­ÛŒ Ùˆ implementation Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ ØªÙˆØ³Ø¹Ù‡ ÙØ±Ø§Ù‡Ù… Ø´Ø¯Ù‡ Ø§Ø³Øª.** 
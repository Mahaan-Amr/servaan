# Ø·Ø±Ø§Ø­ÛŒ Ø³ÛŒØ³ØªÙ… QR/Barcode Scanner - Ø³ÙØ±ÙˆØ§Ù†

**Ù†Ø³Ø®Ù‡**: 1.0  
**ØªØ§Ø±ÛŒØ®**: 2025/01/10  
**ÙˆØ¶Ø¹ÛŒØª**: Design Phase - Ready for Implementation

---

## ğŸ¯ **Ø§Ù‡Ø¯Ø§Ù Ø³ÛŒØ³ØªÙ… Ø§Ø³Ú©Ù†Ø±**

### **Ù‡Ø¯Ù Ø§ØµÙ„ÛŒ**
ØªÙˆØ³Ø¹Ù‡ ÛŒÚ© **Ø³ÛŒØ³ØªÙ… Ø§Ø³Ú©Ù† QR/Barcode Ù¾ÛŒØ´Ø±ÙØªÙ‡ ÙˆØ¨-Ù…Ø­ÙˆØ±** Ú©Ù‡ ÙˆØ±ÙˆØ¯ Ùˆ Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø±Ø§ Ø³Ø±ÛŒØ¹ØŒ Ø¯Ù‚ÛŒÙ‚ Ùˆ Ú©Ø§Ø±Ø¨Ø±Ù¾Ø³Ù†Ø¯ Ú©Ù†Ø¯.

### **Ø§Ù‡Ø¯Ø§Ù ÙØ±Ø¹ÛŒ**
- ğŸ“± **Ø§Ø³Ú©Ù† Ø³Ø±ÛŒØ¹ Ùˆ Ø¯Ù‚ÛŒÙ‚** QR Code Ùˆ Barcode Ø§Ø² Ø·Ø±ÛŒÙ‚ Ù…Ø±ÙˆØ±Ú¯Ø±
- ğŸ“¦ **ÙˆØ±ÙˆØ¯ Ø®ÙˆØ¯Ú©Ø§Ø± Ø§Ø·Ù„Ø§Ø¹Ø§Øª** Ú©Ø§Ù„Ø§ Ø¨Ù‡ Ø³ÛŒØ³ØªÙ… Ù…ÙˆØ¬ÙˆØ¯ÛŒ
- ğŸ” **Ø¬Ø³ØªØ¬ÙˆÛŒ ÙÙˆØ±ÛŒ** Ù…Ø­ØµÙˆÙ„Ø§Øª Ø¨Ø§ Ø§Ø³Ú©Ù†
- ğŸ“Š **ØªÙˆÙ„ÛŒØ¯ QR Code** Ø¨Ø±Ø§ÛŒ Ù…Ø­ØµÙˆÙ„Ø§Øª Ø¯Ø§Ø®Ù„ÛŒ
- ğŸŒ **Ø±Ø§Ø¨Ø· ÙˆØ¨ responsive** Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„ Ùˆ Ø¯Ø³Ú©ØªØ§Ù¾
- ğŸ”„ **Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ real-time** Ø¨Ø§ Ø³ÛŒØ³ØªÙ… Ø§ØµÙ„ÛŒ
- ğŸ“ˆ **Ø¢Ù…Ø§Ø±Ú¯ÛŒØ±ÛŒ** Ø§Ø² ÙØ¹Ø§Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø§Ø³Ú©Ù†

---

## ğŸ—ï¸ **Architecture Ø³ÛŒØ³ØªÙ… Ø§Ø³Ú©Ù†Ø±**

### **Ø³Ø§Ø®ØªØ§Ø± Ú©Ù„ÛŒ**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Servaan Scanner System                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚  Web Scanner    â”‚  â”‚  PWA Scanner    â”‚               â”‚
â”‚  â”‚  (WebRTC)       â”‚  â”‚  (Offline)      â”‚               â”‚ 
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚           â”‚                     â”‚                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚              Scanner Engine                         â”‚â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚â”‚
â”‚  â”‚  â”‚QR Decoder   â”‚ â”‚Barcode      â”‚ â”‚Product      â”‚   â”‚â”‚
â”‚  â”‚  â”‚(ZXing-js)   â”‚ â”‚Decoder      â”‚ â”‚Lookup       â”‚   â”‚â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚(QuaggaJS)   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚â”‚
â”‚  â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚           â”‚                     â”‚                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚  Product        â”‚  â”‚  External APIs  â”‚               â”‚
â”‚  â”‚  Database       â”‚  â”‚  (UPC, EAN)     â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚           â”‚                     â”‚                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚              Integration Layer                      â”‚â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚â”‚
â”‚  â”‚  â”‚Inventory    â”‚ â”‚POS System   â”‚ â”‚Accounting   â”‚   â”‚â”‚
â”‚  â”‚  â”‚System       â”‚ â”‚Integration  â”‚ â”‚Integration  â”‚   â”‚â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸŒ **Web Scanner Design**

### **React Web App Architecture**

```typescript
// Web Scanner Structure
interface WebScannerApp {
  components: {
    scanner: WebcamScanner;
    productDetails: ProductDetailsModal;
    inventory: InventoryView;
    settings: ScannerSettings;
    history: ScanHistoryTable;
  };
  services: {
    cameraService: WebRTCCameraService;
    scannerService: WebBarcodeService;
    apiService: ApiService;
    storageService: IndexedDBService;
  };
}

// Main Scanner Component
interface WebcamScanner {
  camera: WebcamComponent;
  overlay: ScanOverlay;
  controls: ScanControls;
  results: ScanResults;
}
```

### **WebRTC Camera Integration**

```typescript
import Webcam from 'react-webcam';
import Quagga from 'quagga';
import { BrowserMultiFormatReader } from '@zxing/library';

interface WebRTCCameraService {
  setupCamera(): Promise<void>;
  startScanning(): void;
  stopScanning(): void;
  toggleFlash(): void;
  switchCamera(): void;
}

class WebRTCCameraService implements WebRTCCameraService {
  private webcamRef: React.RefObject<Webcam> | null = null;
  private isScanning: boolean = false;
  private scannerActive: boolean = false;
  private devices: MediaDeviceInfo[] = [];
  private selectedDeviceId: string = '';
  
  async setupCamera(): Promise<void> {
    try {
      // Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù…Ø¬ÙˆØ² Ø¯ÙˆØ±Ø¨ÛŒÙ†
      const stream = await navigator.mediaDevices.getUserMedia({ 
        video: { facingMode: 'environment' } 
      });
      
      // Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª Ø¯ÙˆØ±Ø¨ÛŒÙ†â€ŒÙ‡Ø§
      this.devices = await navigator.mediaDevices.enumerateDevices();
      this.devices = this.devices.filter(device => device.kind === 'videoinput');
      
      // Ø§Ù†ØªØ®Ø§Ø¨ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ù¾Ø´ØªÛŒ Ø¨Ø±Ø§ÛŒ Ù…ÙˆØ¨Ø§ÛŒÙ„
      const backCamera = this.devices.find(device => 
        device.label.toLowerCase().includes('back') ||
        device.label.toLowerCase().includes('rear')
      );
      
      this.selectedDeviceId = backCamera?.deviceId || this.devices[0]?.deviceId || '';
      
      // Ù…ØªÙˆÙ‚Ù Ú©Ø±Ø¯Ù† stream Ø§ÙˆÙ„ÛŒÙ‡
      stream.getTracks().forEach(track => track.stop());
      
    } catch (error) {
      throw new Error('Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø§Ù…Ú©Ø§Ù†â€ŒÙ¾Ø°ÛŒØ± Ù†ÛŒØ³Øª');
    }
  }
  
  startScanning(): void {
    if (this.scannerActive) return;
    
    this.isScanning = true;
    this.scannerActive = true;
    
    // Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ QuaggaJS Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø±Ú©Ø¯
    Quagga.init({
      inputStream: {
        name: "Live",
        type: "LiveStream",
        target: document.querySelector('#scanner-container'),
        constraints: {
          width: { min: 640, ideal: 1920, max: 1920 },
          height: { min: 480, ideal: 1080, max: 1080 },
          facingMode: "environment",
          deviceId: this.selectedDeviceId
        }
      },
      locator: {
        patchSize: "medium",
        halfSample: true
      },
      numOfWorkers: navigator.hardwareConcurrency || 2,
      decoder: {
        readers: [
          "code_128_reader",
          "ean_reader", 
          "ean_8_reader",
          "code_39_reader",
          "code_39_vin_reader",
          "codabar_reader",
          "upc_reader",
          "upc_e_reader",
          "i2of5_reader"
        ]
      },
      locate: true
    }, (err) => {
      if (err) {
        console.error('Ø®Ø·Ø§ Ø¯Ø± Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ scanner:', err);
        this.stopScanning();
        return;
      }
      Quagga.start();
    });
    
    // ØªÙ†Ø¸ÛŒÙ… event listener Ø¨Ø±Ø§ÛŒ ØªØ´Ø®ÛŒØµ Ø¨Ø§Ø±Ú©Ø¯
    Quagga.onDetected((data) => {
      if (!this.isScanning) return;
      
      const code = data.codeResult.code;
      const format = data.codeResult.format;
      
      // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² ØªØ´Ø®ÛŒØµ ØªÚ©Ø±Ø§Ø±ÛŒ
      this.temporaryPause();
      
      // Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú©Ø¯ Ø§Ø³Ú©Ù† Ø´Ø¯Ù‡
      this.handleScanResult({
        code,
        format,
        timestamp: Date.now()
      });
    });
  }
  
  stopScanning(): void {
    this.isScanning = false;
    this.scannerActive = false;
    
    if (typeof Quagga !== 'undefined') {
      Quagga.stop();
      Quagga.offDetected();
      Quagga.offProcessed();
    }
  }
  
  private temporaryPause(): void {
    this.isScanning = false;
    setTimeout(() => {
      this.isScanning = true;
    }, 2000); // 2 Ø«Ø§Ù†ÛŒÙ‡ Ù…Ú©Ø«
  }
  
  private async handleScanResult(scanData: ScanResult): Promise<void> {
    try {
      // Ù„Ø±Ø²Ø´ Ùˆ ØµØ¯Ø§ Ø¨Ø±Ø§ÛŒ feedback
      if ('vibrate' in navigator) {
        navigator.vibrate(200);
      }
      
      // Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú©Ø¯
      const result = await WebBarcodeService.processBarcode(scanData);
      
      // Ù†Ù…Ø§ÛŒØ´ Ù†ØªÛŒØ¬Ù‡
      this.showScanResult(result);
      
    } catch (error) {
      console.error('Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú©Ø¯ Ø§Ø³Ú©Ù† Ø´Ø¯Ù‡:', error);
    }
  }
  
  switchCamera(): void {
    if (this.devices.length <= 1) return;
    
    const currentIndex = this.devices.findIndex(d => d.deviceId === this.selectedDeviceId);
    const nextIndex = (currentIndex + 1) % this.devices.length;
    this.selectedDeviceId = this.devices[nextIndex].deviceId;
    
    // Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ù…Ø¬Ø¯Ø¯ scanner Ø¨Ø§ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø¬Ø¯ÛŒØ¯
    this.stopScanning();
    setTimeout(() => this.startScanning(), 500);
  }
}

// Scanner Component
const WebcamScanner: React.FC = () => {
  const webcamRef = useRef<Webcam>(null);
  const [isScanning, setIsScanning] = useState(false);
  const [devices, setDevices] = useState<MediaDeviceInfo[]>([]);
  const [selectedDeviceId, setSelectedDeviceId] = useState('');
  const [scanResult, setScanResult] = useState<ScanResult | null>(null);
  
  const cameraService = useMemo(() => new WebRTCCameraService(), []);
  
  useEffect(() => {
    const initCamera = async () => {
      try {
        await cameraService.setupCamera();
        const availableDevices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = availableDevices.filter(device => device.kind === 'videoinput');
        setDevices(videoDevices);
        
        if (videoDevices.length > 0) {
          setSelectedDeviceId(videoDevices[0].deviceId);
        }
      } catch (error) {
        console.error('Ø®Ø·Ø§ Ø¯Ø± Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø¯ÙˆØ±Ø¨ÛŒÙ†:', error);
      }
    };
    
    initCamera();
    
    return () => {
      cameraService.stopScanning();
    };
  }, [cameraService]);
  
  const startScanning = () => {
    setIsScanning(true);
    cameraService.startScanning();
  };
  
  const stopScanning = () => {
    setIsScanning(false);
    cameraService.stopScanning();
  };
  
  return (
    <div className="scanner-container relative">
      {/* Scanner Container */}
      <div id="scanner-container" className="relative w-full h-96 bg-black rounded-lg overflow-hidden">
        {/* Scanner overlay will be added by QuaggaJS */}
      </div>
      
      {/* Scanner Overlay UI */}
      <div className="absolute inset-0 pointer-events-none">
        <ScanOverlay isScanning={isScanning} />
      </div>
      
      {/* Controls */}
      <div className="mt-4 flex justify-center gap-4">
        <button
          onClick={isScanning ? stopScanning : startScanning}
          className={`px-6 py-3 rounded-lg font-semibold transition-colors ${
            isScanning 
              ? 'bg-red-500 hover:bg-red-600 text-white' 
              : 'bg-blue-500 hover:bg-blue-600 text-white'
          }`}
        >
          {isScanning ? 'ØªÙˆÙ‚Ù Ø§Ø³Ú©Ù†' : 'Ø´Ø±ÙˆØ¹ Ø§Ø³Ú©Ù†'}
        </button>
        
        {devices.length > 1 && (
          <button
            onClick={() => cameraService.switchCamera()}
            className="px-4 py-3 bg-gray-500 hover:bg-gray-600 text-white rounded-lg font-semibold transition-colors"
          >
            ØªØºÛŒÛŒØ± Ø¯ÙˆØ±Ø¨ÛŒÙ†
          </button>
        )}
      </div>
      
      {/* Scan Result Modal */}
      {scanResult && (
        <ScanResultModal 
          result={scanResult} 
          onClose={() => setScanResult(null)}
        />
      )}
    </div>
  );
};
```

---

## ğŸ“Š **Integration with Inventory System**

### **Inventory Integration Service**

```typescript
class InventoryIntegrationService {
  // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ù…Ø­ØµÙˆÙ„ Ø§Ø² Ø·Ø±ÛŒÙ‚ Ø§Ø³Ú©Ù†
  static async addProductFromScan(
    scanResult: ScanResult,
    quantity: number,
    location?: string
  ): Promise<InventoryEntry> {
    
    try {
      // Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ Ù…Ø­ØµÙˆÙ„ Ø¯Ø± Ø³ÛŒØ³ØªÙ…
      let item = await this.findExistingItem(scanResult.value);
      
      // Ø§Ú¯Ø± Ù…Ø­ØµÙˆÙ„ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯ØŒ Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø­ØµÙˆÙ„ Ø¬Ø¯ÛŒØ¯
      if (!item) {
        item = await this.createNewItem(scanResult);
      }
      
      // Ø§ÛŒØ¬Ø§Ø¯ ÙˆØ±ÙˆØ¯ÛŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒ
      const inventoryEntry: InventoryEntry = {
        itemId: item.id,
        type: 'IN',
        quantity,
        unitPrice: item.costPrice || 0,
        totalPrice: (item.costPrice || 0) * quantity,
        date: new Date(),
        notes: `Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡ Ø§Ø² Ø·Ø±ÛŒÙ‚ Ø§Ø³Ú©Ù†: ${scanResult.value}`,
        location,
        scannedCode: scanResult.value,
        scanTimestamp: scanResult.timestamp
      };
      
      // Ø«Ø¨Øª Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ù…ÙˆØ¬ÙˆØ¯ÛŒ
      const savedEntry = await ApiService.post('/api/inventory', inventoryEntry);
      
      // Ø§Ø±Ø³Ø§Ù„ Ù†ÙˆØªÛŒÙÛŒÚ©ÛŒØ´Ù†
      await NotificationService.send({
        type: 'INVENTORY_ADDED',
        title: 'Ù…Ø­ØµÙˆÙ„ Ø¬Ø¯ÛŒØ¯ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯',
        message: `${item.name} - ØªØ¹Ø¯Ø§Ø¯: ${quantity}`,
        data: { itemId: item.id, entryId: savedEntry.id }
      });
      
      return savedEntry;
      
    } catch (error) {
      throw new Error(`Ø®Ø·Ø§ Ø¯Ø± Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ù…Ø­ØµÙˆÙ„: ${error.message}`);
    }
  }
  
  // Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ø­ØµÙˆÙ„ Ù…ÙˆØ¬ÙˆØ¯
  private static async findExistingItem(code: string): Promise<Item | null> {
    try {
      const response = await ApiService.get(`/api/items/search?barcode=${code}`);
      return response.data;
    } catch (error) {
      return null;
    }
  }
  
  // Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø­ØµÙˆÙ„ Ø¬Ø¯ÛŒØ¯
  private static async createNewItem(scanResult: ScanResult): Promise<Item> {
    const itemData: Partial<Item> = {
      name: scanResult.product?.name || `Ù…Ø­ØµÙˆÙ„ ${scanResult.value}`,
      description: scanResult.product?.description,
      barcode: scanResult.value,
      categoryId: await this.getDefaultCategoryId(),
      unitPrice: scanResult.product?.price || 0,
      costPrice: scanResult.product?.price || 0,
      minQuantity: 5,
      isActive: true,
      createdFromScan: true
    };
    
    const response = await ApiService.post('/api/items', itemData);
    return response.data;
  }
  
  // Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ù¾ÛŒØ´â€ŒÙØ±Ø¶
  private static async getDefaultCategoryId(): Promise<string> {
    try {
      const response = await ApiService.get('/api/categories?default=true');
      return response.data[0]?.id || null;
    } catch (error) {
      return null;
    }
  }
  
  // Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø§Ø² Ø·Ø±ÛŒÙ‚ Ø§Ø³Ú©Ù†
  static async updateInventoryFromScan(
    itemId: string,
    newQuantity: number,
    reason: string
  ): Promise<InventoryEntry> {
    
    // Ø¯Ø±ÛŒØ§ÙØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ ÙØ¹Ù„ÛŒ
    const currentInventory = await ApiService.get(`/api/inventory/current/${itemId}`);
    const currentQuantity = currentInventory.data.quantity;
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ ØªØºÛŒÛŒØ±
    const quantityChange = newQuantity - currentQuantity;
    const entryType = quantityChange > 0 ? 'IN' : 'OUT';
    
    const inventoryEntry: InventoryEntry = {
      itemId,
      type: entryType,
      quantity: Math.abs(quantityChange),
      unitPrice: 0,
      totalPrice: 0,
      date: new Date(),
      notes: `Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø² Ø·Ø±ÛŒÙ‚ Ø§Ø³Ú©Ù†: ${reason}`,
      isAdjustment: true
    };
    
    return await ApiService.post('/api/inventory', inventoryEntry);
  }
  
  // Ú¯Ø²Ø§Ø±Ø´ Ø§Ø³Ú©Ù†â€ŒÙ‡Ø§ÛŒ Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯Ù‡
  static async getScanReport(
    startDate: Date,
    endDate: Date
  ): Promise<ScanReport> {
    
    const response = await ApiService.get('/api/scan-history', {
      params: {
        startDate: startDate.toISOString(),
        endDate: endDate.toISOString()
      }
    });
    
    const scanHistory = response.data;
    
    return {
      totalScans: scanHistory.length,
      successfulScans: scanHistory.filter(s => s.product).length,
      failedScans: scanHistory.filter(s => !s.product).length,
      newProductsAdded: scanHistory.filter(s => s.createdNewProduct).length,
      mostScannedProducts: this.getMostScannedProducts(scanHistory),
      scansByHour: this.groupScansByHour(scanHistory),
      scansByDay: this.groupScansByDay(scanHistory)
    };
  }
  
  private static getMostScannedProducts(scanHistory: ScanResult[]): ProductScanCount[] {
    const productCounts = new Map<string, number>();
    
    scanHistory.forEach(scan => {
      if (scan.product?.id) {
        const count = productCounts.get(scan.product.id) || 0;
        productCounts.set(scan.product.id, count + 1);
      }
    });
    
    return Array.from(productCounts.entries())
      .map(([productId, count]) => ({ productId, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);
  }
}
```

---

## ğŸ“± **Mobile App Screens**

### **Product Details Screen**

```typescript
const ProductDetailsScreen: React.FC<{ route: any }> = ({ route }) => {
  const { scanResult } = route.params;
  const [product, setProduct] = useState<ProductInfo | null>(scanResult.product);
  const [quantity, setQuantity] = useState('1');
  const [loading, setLoading] = useState(false);
  
  const handleAddToInventory = async () => {
    setLoading(true);
    try {
      await InventoryIntegrationService.addProductFromScan(
        scanResult,
        parseInt(quantity)
      );
      
      Alert.alert('Ù…ÙˆÙÙ‚', 'Ù…Ø­ØµÙˆÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯');
      navigation.goBack();
      
    } catch (error) {
      Alert.alert('Ø®Ø·Ø§', error.message);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <ScrollView style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>Ø¬Ø²Ø¦ÛŒØ§Øª Ù…Ø­ØµÙˆÙ„</Text>
        <Text style={styles.code}>Ú©Ø¯: {scanResult.value}</Text>
      </View>
      
      {product?.imageUrl && (
        <Image source={{ uri: product.imageUrl }} style={styles.productImage} />
      )}
      
      <View style={styles.details}>
        <Text style={styles.productName}>{product?.name || 'Ù†Ø§Ù… Ù…Ø­ØµÙˆÙ„'}</Text>
        <Text style={styles.description}>{product?.description}</Text>
        <Text style={styles.brand}>Ø¨Ø±Ù†Ø¯: {product?.brand}</Text>
        <Text style={styles.category}>Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ: {product?.category}</Text>
      </View>
      
      <View style={styles.quantitySection}>
        <Text style={styles.label}>ØªØ¹Ø¯Ø§Ø¯:</Text>
        <TextInput
          style={styles.quantityInput}
          value={quantity}
          onChangeText={setQuantity}
          keyboardType="numeric"
          placeholder="ØªØ¹Ø¯Ø§Ø¯"
        />
      </View>
      
      <TouchableOpacity
        style={[styles.addButton, loading && styles.disabledButton]}
        onPress={handleAddToInventory}
        disabled={loading}
      >
        <Text style={styles.addButtonText}>
          {loading ? 'Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù†...' : 'Ø§Ø¶Ø§ÙÙ‡ Ø¨Ù‡ Ù…ÙˆØ¬ÙˆØ¯ÛŒ'}
        </Text>
      </TouchableOpacity>
    </ScrollView>
  );
};
```

### **Scan History Screen**

```typescript
const ScanHistoryScreen: React.FC = () => {
  const [scanHistory, setScanHistory] = useState<ScanResult[]>([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState<'ALL' | 'SUCCESS' | 'FAILED'>('ALL');
  
  useEffect(() => {
    loadScanHistory();
  }, []);
  
  const loadScanHistory = async () => {
    try {
      const history = await StorageService.getScanHistory();
      setScanHistory(history);
    } catch (error) {
      Alert.alert('Ø®Ø·Ø§', 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ØªØ§Ø±ÛŒØ®Ú†Ù‡');
    } finally {
      setLoading(false);
    }
  };
  
  const filteredHistory = scanHistory.filter(scan => {
    switch (filter) {
      case 'SUCCESS':
        return scan.product !== undefined;
      case 'FAILED':
        return scan.product === undefined;
      default:
        return true;
    }
  });
  
  const renderScanItem = ({ item }: { item: ScanResult }) => (
    <View style={styles.scanItem}>
      <View style={styles.scanHeader}>
        <Text style={styles.scanCode}>{item.value}</Text>
        <Text style={styles.scanTime}>
          {item.timestamp.toLocaleString('fa-IR')}
        </Text>
      </View>
      
      {item.product ? (
        <View style={styles.productInfo}>
          <Text style={styles.productName}>{item.product.name}</Text>
          <Text style={styles.productDescription}>{item.product.description}</Text>
        </View>
      ) : (
        <Text style={styles.noProduct}>Ù…Ø­ØµÙˆÙ„ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ù†Ø´Ø¯</Text>
      )}
      
      <View style={styles.scanType}>
        <Text style={[
          styles.typeText,
          item.type === 'QR_CODE' ? styles.qrType : styles.barcodeType
        ]}>
          {item.type === 'QR_CODE' ? 'QR Code' : 'Barcode'}
        </Text>
      </View>
    </View>
  );
  
  return (
    <View style={styles.container}>
      <View style={styles.filterContainer}>
        <TouchableOpacity
          style={[styles.filterButton, filter === 'ALL' && styles.activeFilter]}
          onPress={() => setFilter('ALL')}
        >
          <Text>Ù‡Ù…Ù‡</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.filterButton, filter === 'SUCCESS' && styles.activeFilter]}
          onPress={() => setFilter('SUCCESS')}
        >
          <Text>Ù…ÙˆÙÙ‚</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.filterButton, filter === 'FAILED' && styles.activeFilter]}
          onPress={() => setFilter('FAILED')}
        >
          <Text>Ù†Ø§Ù…ÙˆÙÙ‚</Text>
        </TouchableOpacity>
      </View>
      
      <FlatList
        data={filteredHistory}
        renderItem={renderScanItem}
        keyExtractor={(item, index) => `${item.value}-${index}`}
        refreshing={loading}
        onRefresh={loadScanHistory}
        ListEmptyComponent={
          <Text style={styles.emptyText}>ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ø§Ø³Ú©Ù†ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯</Text>
        }
      />
    </View>
  );
};
```

**ğŸ¯ Ø³ÛŒØ³ØªÙ… QR/Barcode Scanner Ú©Ø§Ù…Ù„ Ø¢Ù…Ø§Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø§Ø³Øª! ØªÙ…Ø§Ù… ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¨Ø§ÛŒÙ„ØŒ ÙˆØ¨ØŒ ØªÙˆÙ„ÛŒØ¯ QR Code Ùˆ ÛŒÚ©Ù¾Ø§Ø±Ú†Ú¯ÛŒ Ø¨Ø§ Ø³ÛŒØ³ØªÙ… Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø·Ø±Ø§Ø­ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª.** 
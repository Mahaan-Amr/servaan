# Ø·Ø±Ø§Ø­ÛŒ Ø³ÛŒØ³ØªÙ… Business Intelligence - Ø³ÙØ±ÙˆØ§Ù†

**Ù†Ø³Ø®Ù‡**: 1.0  
**ØªØ§Ø±ÛŒØ®**: 2025/01/10  
**ÙˆØ¶Ø¹ÛŒØª**: Design Phase - Ready for Implementation

---

## ğŸ¯ **Ø§Ù‡Ø¯Ø§Ù Ø³ÛŒØ³ØªÙ… BI**

### **Ù‡Ø¯Ù Ø§ØµÙ„ÛŒ**
ØªÙˆØ³Ø¹Ù‡ ÛŒÚ© **Ø³ÛŒØ³ØªÙ… Ù‡ÙˆØ´ ØªØ¬Ø§Ø±ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡** Ú©Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„ÛŒØ§ØªÛŒ Ø³ÙØ±ÙˆØ§Ù† Ø±Ø§ Ø¨Ù‡ Ø¨ÛŒÙ†Ø´â€ŒÙ‡Ø§ÛŒ Ù‚Ø§Ø¨Ù„ Ø§Ø¬Ø±Ø§ ØªØ¨Ø¯ÛŒÙ„ Ú©Ù†Ø¯ Ùˆ ØªØµÙ…ÛŒÙ…â€ŒÚ¯ÛŒØ±ÛŒ Ù…Ø¯ÛŒØ±ÛŒØªÛŒ Ø±Ø§ Ø¨Ù‡Ø¨ÙˆØ¯ Ø¨Ø®Ø´Ø¯.

### **Ø§Ù‡Ø¯Ø§Ù ÙØ±Ø¹ÛŒ**
- ğŸ“Š **Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ KPI Ù‡Ø§ÛŒ Ú©Ù„ÛŒØ¯ÛŒ** Ø¨Ø§ Ù†Ù…Ø§ÛŒØ´ real-time
- ğŸ“ˆ **ØªØ­Ù„ÛŒÙ„ Ø±ÙˆÙ†Ø¯Ù‡Ø§** Ùˆ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø¢ÛŒÙ†Ø¯Ù‡
- ğŸ¯ **ØªØ­Ù„ÛŒÙ„ Ø³ÙˆØ¯Ø¢ÙˆØ±ÛŒ** Ø¯Ù‚ÛŒÙ‚ Ùˆ Ú†Ù†Ø¯Ø¨Ø¹Ø¯ÛŒ
- ğŸ“‹ **Ú¯Ø²Ø§Ø±Ø´â€ŒØ³Ø§Ø² Ù‚Ø§Ø¨Ù„ ØªÙ†Ø¸ÛŒÙ…** Ø¨Ø±Ø§ÛŒ Ù†ÛŒØ§Ø²Ù‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù
- ğŸ“¤ **Ø®Ø±ÙˆØ¬ÛŒ Ú†Ù†Ø¯ÙØ±Ù…ØªÙ‡** (Excel, PDF, CSV)
- ğŸ” **ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡** (ABC, Pareto, Cohort)
- ğŸš¨ **Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯** Ùˆ Ù†Ø¸Ø§Ø±Øª Ø®ÙˆØ¯Ú©Ø§Ø±

---

## ğŸ—ï¸ **Architecture Ø³ÛŒØ³ØªÙ… BI**

### **Ø³Ø§Ø®ØªØ§Ø± Ú©Ù„ÛŒ**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Servaan BI System                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚  Data Sources   â”‚  â”‚  ETL Pipeline   â”‚               â”‚
â”‚  â”‚  (POS, Inv,     â”‚  â”‚  (Extract,      â”‚               â”‚
â”‚  â”‚   Accounting)   â”‚  â”‚   Transform,    â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   Load)         â”‚               â”‚
â”‚           â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚           â”‚                     â”‚                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚              Data Warehouse                         â”‚â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚â”‚
â”‚  â”‚  â”‚Fact Tables  â”‚ â”‚Dimension    â”‚ â”‚Aggregated   â”‚   â”‚â”‚
â”‚  â”‚  â”‚(Sales,      â”‚ â”‚Tables       â”‚ â”‚Views        â”‚   â”‚â”‚
â”‚  â”‚  â”‚ Inventory)  â”‚ â”‚(Time, Item) â”‚ â”‚             â”‚   â”‚â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚           â”‚                     â”‚                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚  Analytics      â”‚  â”‚  Visualization  â”‚               â”‚
â”‚  â”‚  Engine         â”‚  â”‚  Layer          â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚           â”‚                     â”‚                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚                 BI Dashboard                        â”‚â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚â”‚
â”‚  â”‚  â”‚Executive    â”‚ â”‚Operational  â”‚ â”‚Financial    â”‚   â”‚â”‚
â”‚  â”‚  â”‚Dashboard    â”‚ â”‚Dashboard    â”‚ â”‚Dashboard    â”‚   â”‚â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“Š **KPI Dashboard Design**

### **Executive Dashboard (Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ù…Ø¯ÛŒØ±ÛŒØªÛŒ)**

```typescript
interface ExecutiveDashboard {
  period: DateRange;
  kpis: {
    // KPI Ù‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ
    totalRevenue: KPIMetric;
    netProfit: KPIMetric;
    profitMargin: KPIMetric;
    cashFlow: KPIMetric;
    
    // KPI Ù‡Ø§ÛŒ Ø¹Ù…Ù„ÛŒØ§ØªÛŒ
    customerCount: KPIMetric;
    averageOrderValue: KPIMetric;
    inventoryTurnover: KPIMetric;
    stockoutRate: KPIMetric;
    
    // KPI Ù‡Ø§ÛŒ Ø±Ø´Ø¯
    revenueGrowth: KPIMetric;
    customerGrowth: KPIMetric;
    marketShare: KPIMetric;
  };
  charts: {
    revenueChart: TimeSeriesChart;
    profitabilityChart: PieChart;
    topProductsChart: BarChart;
    customerSegmentChart: DonutChart;
  };
  alerts: Alert[];
}

interface KPIMetric {
  value: number;
  previousValue: number;
  change: number;
  changePercent: number;
  trend: 'UP' | 'DOWN' | 'STABLE';
  target?: number;
  status: 'GOOD' | 'WARNING' | 'CRITICAL';
  unit: string;
  description: string;
}
```

### **KPI Ù‡Ø§ÛŒ Ú©Ù„ÛŒØ¯ÛŒ**

#### **1. KPI Ù‡Ø§ÛŒ Ù…Ø§Ù„ÛŒ**

```typescript
class FinancialKPIs {
  // Ø¯Ø±Ø¢Ù…Ø¯ Ú©Ù„
  async getTotalRevenue(period: DateRange): Promise<KPIMetric> {
    const currentRevenue = await this.calculateRevenue(period);
    const previousPeriod = this.getPreviousPeriod(period);
    const previousRevenue = await this.calculateRevenue(previousPeriod);
    
    return {
      value: currentRevenue,
      previousValue: previousRevenue,
      change: currentRevenue - previousRevenue,
      changePercent: ((currentRevenue - previousRevenue) / previousRevenue) * 100,
      trend: currentRevenue > previousRevenue ? 'UP' : 'DOWN',
      unit: 'ØªÙˆÙ…Ø§Ù†',
      description: 'Ù…Ø¬Ù…ÙˆØ¹ Ø¯Ø±Ø¢Ù…Ø¯ Ø§Ø² ÙØ±ÙˆØ´',
      status: this.determineStatus(currentRevenue, previousRevenue)
    };
  }
  
  // Ø³ÙˆØ¯ Ø®Ø§Ù„Øµ
  async getNetProfit(period: DateRange): Promise<KPIMetric> {
    const revenue = await this.calculateRevenue(period);
    const costs = await this.calculateTotalCosts(period);
    const netProfit = revenue - costs;
    
    const previousPeriod = this.getPreviousPeriod(period);
    const previousProfit = await this.getNetProfit(previousPeriod);
    
    return {
      value: netProfit,
      previousValue: previousProfit.value,
      change: netProfit - previousProfit.value,
      changePercent: ((netProfit - previousProfit.value) / previousProfit.value) * 100,
      trend: netProfit > previousProfit.value ? 'UP' : 'DOWN',
      unit: 'ØªÙˆÙ…Ø§Ù†',
      description: 'Ø³ÙˆØ¯ Ø®Ø§Ù„Øµ Ù¾Ø³ Ø§Ø² Ú©Ø³Ø± ØªÙ…Ø§Ù… Ù‡Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§'
    };
  }
  
  // Ø­Ø§Ø´ÛŒÙ‡ Ø³ÙˆØ¯
  async getProfitMargin(period: DateRange): Promise<KPIMetric> {
    const revenue = await this.calculateRevenue(period);
    const netProfit = await this.getNetProfit(period);
    const margin = (netProfit.value / revenue) * 100;
    
    return {
      value: margin,
      unit: 'Ø¯Ø±ØµØ¯',
      description: 'Ø¯Ø±ØµØ¯ Ø³ÙˆØ¯ Ù†Ø³Ø¨Øª Ø¨Ù‡ ÙØ±ÙˆØ´',
      target: 15, // Ù‡Ø¯Ù 15% Ø­Ø§Ø´ÛŒÙ‡ Ø³ÙˆØ¯
      status: margin >= 15 ? 'GOOD' : margin >= 10 ? 'WARNING' : 'CRITICAL'
    };
  }
  
  // Ú¯Ø±Ø¯Ø´ Ù…ÙˆØ¬ÙˆØ¯ÛŒ
  async getInventoryTurnover(period: DateRange): Promise<KPIMetric> {
    const cogs = await this.getCostOfGoodsSold(period);
    const avgInventory = await this.getAverageInventoryValue(period);
    const turnover = cogs / avgInventory;
    
    return {
      value: turnover,
      unit: 'Ø¨Ø§Ø± Ø¯Ø± Ø³Ø§Ù„',
      description: 'ØªØ¹Ø¯Ø§Ø¯ Ø¯ÙØ¹Ø§Øª Ú¯Ø±Ø¯Ø´ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø¯Ø± Ø³Ø§Ù„',
      target: 12, // Ù‡Ø¯Ù 12 Ø¨Ø§Ø± Ø¯Ø± Ø³Ø§Ù„ (Ù…Ø§Ù‡Ø§Ù†Ù‡)
      status: turnover >= 12 ? 'GOOD' : turnover >= 8 ? 'WARNING' : 'CRITICAL'
    };
  }
}
```

#### **2. KPI Ù‡Ø§ÛŒ Ø¹Ù…Ù„ÛŒØ§ØªÛŒ**

```typescript
class OperationalKPIs {
  // Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø§Ø±Ø²Ø´ Ø³ÙØ§Ø±Ø´
  async getAverageOrderValue(period: DateRange): Promise<KPIMetric> {
    const transactions = await this.getPOSTransactions(period);
    const totalRevenue = transactions.reduce((sum, t) => sum + t.totalAmount, 0);
    const orderCount = transactions.length;
    const aov = totalRevenue / orderCount;
    
    return {
      value: aov,
      unit: 'ØªÙˆÙ…Ø§Ù†',
      description: 'Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ù…Ø¨Ù„Øº Ù‡Ø± Ø³ÙØ§Ø±Ø´',
      target: 50000, // Ù‡Ø¯Ù 50 Ù‡Ø²Ø§Ø± ØªÙˆÙ…Ø§Ù†
      status: aov >= 50000 ? 'GOOD' : aov >= 35000 ? 'WARNING' : 'CRITICAL'
    };
  }
  
  // Ù†Ø±Ø® Ú©Ù…Ø¨ÙˆØ¯ Ù…ÙˆØ¬ÙˆØ¯ÛŒ
  async getStockoutRate(period: DateRange): Promise<KPIMetric> {
    const totalItems = await this.getTotalActiveItems();
    const stockoutEvents = await this.getStockoutEvents(period);
    const stockoutRate = (stockoutEvents.length / totalItems) * 100;
    
    return {
      value: stockoutRate,
      unit: 'Ø¯Ø±ØµØ¯',
      description: 'Ø¯Ø±ØµØ¯ Ú©Ø§Ù„Ø§Ù‡Ø§ÛŒÛŒ Ú©Ù‡ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø¢Ù†Ù‡Ø§ Ø¨Ù‡ Ø§ØªÙ…Ø§Ù… Ø±Ø³ÛŒØ¯Ù‡',
      target: 5, // Ø­Ø¯Ø§Ú©Ø«Ø± 5% Ù‚Ø§Ø¨Ù„ Ù‚Ø¨ÙˆÙ„
      status: stockoutRate <= 5 ? 'GOOD' : stockoutRate <= 10 ? 'WARNING' : 'CRITICAL'
    };
  }
  
  // ØªØ¹Ø¯Ø§Ø¯ Ù…Ø´ØªØ±ÛŒØ§Ù† Ù…Ù†Ø­ØµØ± Ø¨Ù‡ ÙØ±Ø¯
  async getUniqueCustomers(period: DateRange): Promise<KPIMetric> {
    const transactions = await this.getPOSTransactions(period);
    const uniqueCustomers = new Set(
      transactions
        .filter(t => t.customerId)
        .map(t => t.customerId)
    ).size;
    
    return {
      value: uniqueCustomers,
      unit: 'Ù†ÙØ±',
      description: 'ØªØ¹Ø¯Ø§Ø¯ Ù…Ø´ØªØ±ÛŒØ§Ù† Ù…Ù†Ø­ØµØ± Ø¨Ù‡ ÙØ±Ø¯'
    };
  }
  
  // Ù†Ø±Ø® Ø¨Ø§Ø²Ú¯Ø´Øª Ù…Ø´ØªØ±ÛŒ
  async getCustomerRetentionRate(period: DateRange): Promise<KPIMetric> {
    const previousPeriod = this.getPreviousPeriod(period);
    const currentCustomers = await this.getUniqueCustomers(period);
    const previousCustomers = await this.getUniqueCustomers(previousPeriod);
    const returningCustomers = await this.getReturningCustomers(period, previousPeriod);
    
    const retentionRate = (returningCustomers / previousCustomers.value) * 100;
    
    return {
      value: retentionRate,
      unit: 'Ø¯Ø±ØµØ¯',
      description: 'Ø¯Ø±ØµØ¯ Ù…Ø´ØªØ±ÛŒØ§Ù†ÛŒ Ú©Ù‡ Ø¯Ø± Ø¯ÙˆØ±Ù‡ Ø¬Ø§Ø±ÛŒ Ù†ÛŒØ² Ø®Ø±ÛŒØ¯ Ú©Ø±Ø¯Ù‡â€ŒØ§Ù†Ø¯',
      target: 60, // Ù‡Ø¯Ù 60% Ø¨Ø§Ø²Ú¯Ø´Øª
      status: retentionRate >= 60 ? 'GOOD' : retentionRate >= 40 ? 'WARNING' : 'CRITICAL'
    };
  }
}
```

#### **3. KPI Ù‡Ø§ÛŒ Ù…Ø­ØµÙˆÙ„**

```typescript
class ProductKPIs {
  // Ù¾Ø±ÙØ±ÙˆØ´â€ŒØªØ±ÛŒÙ† Ù…Ø­ØµÙˆÙ„Ø§Øª
  async getTopSellingProducts(
    period: DateRange, 
    limit: number = 10
  ): Promise<ProductPerformance[]> {
    const salesData = await this.getProductSalesData(period);
    
    return salesData
      .sort((a, b) => b.totalSales - a.totalSales)
      .slice(0, limit)
      .map((product, index) => ({
        rank: index + 1,
        itemId: product.itemId,
        itemName: product.itemName,
        category: product.category,
        totalSales: product.totalSales,
        quantitySold: product.quantitySold,
        profit: product.profit,
        profitMargin: (product.profit / product.totalSales) * 100,
        salesGrowth: product.salesGrowth
      }));
  }
  
  // Ù…Ø­ØµÙˆÙ„Ø§Øª Ú©Ù…â€ŒÙØ±ÙˆØ´
  async getSlowMovingProducts(period: DateRange): Promise<ProductPerformance[]> {
    const salesData = await this.getProductSalesData(period);
    const threshold = await this.calculateSlowMovingThreshold(period);
    
    return salesData
      .filter(product => product.quantitySold < threshold)
      .sort((a, b) => a.quantitySold - b.quantitySold);
  }
  
  // ØªØ­Ù„ÛŒÙ„ ABC Ù…Ø­ØµÙˆÙ„Ø§Øª
  async getProductABCAnalysis(period: DateRange): Promise<ABCAnalysis> {
    const products = await this.getAllProductsWithSales(period);
    const totalSales = products.reduce((sum, p) => sum + p.totalSales, 0);
    
    // Ù…Ø±ØªØ¨â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ ÙØ±ÙˆØ´
    const sorted = products.sort((a, b) => b.totalSales - a.totalSales);
    
    let cumulativeSales = 0;
    const classified = sorted.map(product => {
      cumulativeSales += product.totalSales;
      const cumulativePercent = (cumulativeSales / totalSales) * 100;
      
      let category: 'A' | 'B' | 'C';
      if (cumulativePercent <= 80) {
        category = 'A'; // 80% ÙØ±ÙˆØ´
      } else if (cumulativePercent <= 95) {
        category = 'B'; // 15% ÙØ±ÙˆØ´
      } else {
        category = 'C'; // 5% ÙØ±ÙˆØ´
      }
      
      return { ...product, abcCategory: category, cumulativePercent };
    });
    
    return {
      period,
      products: classified,
      summary: {
        categoryA: classified.filter(p => p.abcCategory === 'A'),
        categoryB: classified.filter(p => p.abcCategory === 'B'),
        categoryC: classified.filter(p => p.abcCategory === 'C')
      }
    };
  }
}
```

---

## ğŸ“ˆ **Advanced Analytics**

### **1. Cohort Analysis (ØªØ­Ù„ÛŒÙ„ Ú©ÙˆÙ‡ÙˆØ±Øª)**

```typescript
class CohortAnalysis {
  async generateCustomerCohorts(
    startDate: Date,
    endDate: Date,
    cohortType: 'MONTHLY' | 'WEEKLY' = 'MONTHLY'
  ): Promise<CohortAnalysisResult> {
    
    const customers = await this.getCustomersWithFirstPurchase(startDate, endDate);
    const cohorts: CohortData[] = [];
    
    for (const customer of customers) {
      const cohortPeriod = this.getCohortPeriod(customer.firstPurchaseDate, cohortType);
      const subsequentPurchases = await this.getCustomerPurchases(
        customer.id, 
        customer.firstPurchaseDate, 
        endDate
      );
      
      // Ù…Ø­Ø§Ø³Ø¨Ù‡ retention Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ø¯ÙˆØ±Ù‡
      const retentionData = this.calculateRetentionPeriods(
        customer.firstPurchaseDate,
        subsequentPurchases,
        cohortType
      );
      
      cohorts.push({
        customerId: customer.id,
        cohortPeriod,
        firstPurchaseDate: customer.firstPurchaseDate,
        retentionPeriods: retentionData
      });
    }
    
    // ØªØ¬Ù…ÛŒØ¹ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø¨Ø± Ø§Ø³Ø§Ø³ Ú©ÙˆÙ‡ÙˆØ±Øª
    const aggregatedCohorts = this.aggregateCohortData(cohorts);
    
    return {
      cohortType,
      period: { startDate, endDate },
      cohorts: aggregatedCohorts,
      insights: this.generateCohortInsights(aggregatedCohorts)
    };
  }
  
  private generateCohortInsights(cohorts: AggregatedCohortData[]): CohortInsight[] {
    const insights: CohortInsight[] = [];
    
    // Ø¨Ù‡ØªØ±ÛŒÙ† Ú©ÙˆÙ‡ÙˆØ±Øª Ø§Ø² Ù†Ø¸Ø± retention
    const bestCohort = cohorts.reduce((best, current) => 
      current.month3Retention > best.month3Retention ? current : best
    );
    
    insights.push({
      type: 'BEST_COHORT',
      message: `Ú©ÙˆÙ‡ÙˆØ±Øª ${bestCohort.cohortPeriod} Ø¨Ù‡ØªØ±ÛŒÙ† Ù†Ø±Ø® Ø¨Ø§Ø²Ú¯Ø´Øª Ø±Ø§ Ø¯Ø§Ø±Ø¯: ${bestCohort.month3Retention.toFixed(1)}%`,
      actionable: true,
      recommendation: 'ØªØ­Ù„ÛŒÙ„ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø§ÛŒÙ† Ú©ÙˆÙ‡ÙˆØ±Øª Ùˆ ØªÚ©Ø±Ø§Ø± Ø´Ø±Ø§ÛŒØ· Ù…Ø´Ø§Ø¨Ù‡'
    });
    
    // Ø±ÙˆÙ†Ø¯ Ú©Ù„ÛŒ retention
    const avgRetention = cohorts.reduce((sum, c) => sum + c.month1Retention, 0) / cohorts.length;
    if (avgRetention < 30) {
      insights.push({
        type: 'LOW_RETENTION',
        message: `Ù†Ø±Ø® Ø¨Ø§Ø²Ú¯Ø´Øª Ù…Ø§Ù‡ Ø§ÙˆÙ„ Ù¾Ø§ÛŒÛŒÙ† Ø§Ø³Øª: ${avgRetention.toFixed(1)}%`,
        actionable: true,
        recommendation: 'Ø¨Ø±Ø±Ø³ÛŒ ØªØ¬Ø±Ø¨Ù‡ Ù…Ø´ØªØ±ÛŒ Ùˆ Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒÙ‡Ø§ÛŒ ÙˆÙØ§Ø¯Ø§Ø±ÛŒ'
      });
    }
    
    return insights;
  }
}
```

### **2. Predictive Analytics (ØªØ­Ù„ÛŒÙ„ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ)**

```typescript
class PredictiveAnalytics {
  // Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ ÙØ±ÙˆØ´
  async forecastSales(
    forecastPeriod: number, // ØªØ¹Ø¯Ø§Ø¯ Ù…Ø§Ù‡ Ø¢ÛŒÙ†Ø¯Ù‡
    method: 'LINEAR_REGRESSION' | 'MOVING_AVERAGE' | 'EXPONENTIAL_SMOOTHING' = 'LINEAR_REGRESSION'
  ): Promise<SalesForecast> {
    
    const historicalData = await this.getHistoricalSalesData(24); // 24 Ù…Ø§Ù‡ Ú¯Ø°Ø´ØªÙ‡
    
    let forecast: ForecastPoint[];
    
    switch (method) {
      case 'LINEAR_REGRESSION':
        forecast = this.linearRegressionForecast(historicalData, forecastPeriod);
        break;
      case 'MOVING_AVERAGE':
        forecast = this.movingAverageForecast(historicalData, forecastPeriod);
        break;
      case 'EXPONENTIAL_SMOOTHING':
        forecast = this.exponentialSmoothingForecast(historicalData, forecastPeriod);
        break;
    }
    
    return {
      method,
      forecastPeriod,
      historicalData,
      forecast,
      confidence: this.calculateConfidenceInterval(forecast),
      accuracy: await this.calculateForecastAccuracy(method)
    };
  }
  
  // Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ ØªÙ‚Ø§Ø¶Ø§ Ø¨Ø±Ø§ÛŒ Ù…Ø­ØµÙˆÙ„Ø§Øª
  async forecastDemand(
    itemId: string,
    forecastDays: number = 30
  ): Promise<DemandForecast> {
    
    const salesHistory = await this.getItemSalesHistory(itemId, 90); // 90 Ø±ÙˆØ² Ú¯Ø°Ø´ØªÙ‡
    const seasonality = await this.detectSeasonality(salesHistory);
    const trend = this.calculateTrend(salesHistory);
    
    const forecast = this.generateDemandForecast(
      salesHistory,
      seasonality,
      trend,
      forecastDays
    );
    
    return {
      itemId,
      forecastDays,
      dailyForecast: forecast,
      totalForecast: forecast.reduce((sum, day) => sum + day.quantity, 0),
      confidence: this.calculateDemandConfidence(forecast),
      recommendedOrderQuantity: this.calculateOptimalOrderQuantity(forecast)
    };
  }
  
  // ØªØ´Ø®ÛŒØµ Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ ÙØ±ÙˆØ´
  async detectSalesPatterns(period: DateRange): Promise<SalesPattern[]> {
    const salesData = await this.getDetailedSalesData(period);
    const patterns: SalesPattern[] = [];
    
    // Ø§Ù„Ú¯ÙˆÛŒ Ø±ÙˆØ²Ù‡Ø§ÛŒ Ù‡ÙØªÙ‡
    const weekdayPattern = this.analyzeWeekdayPattern(salesData);
    patterns.push({
      type: 'WEEKDAY',
      description: 'Ø§Ù„Ú¯ÙˆÛŒ ÙØ±ÙˆØ´ Ø¯Ø± Ø±ÙˆØ²Ù‡Ø§ÛŒ Ù‡ÙØªÙ‡',
      data: weekdayPattern,
      insight: this.generateWeekdayInsight(weekdayPattern)
    });
    
    // Ø§Ù„Ú¯ÙˆÛŒ Ø³Ø§Ø¹Ø§Øª Ø±ÙˆØ²
    const hourlyPattern = this.analyzeHourlyPattern(salesData);
    patterns.push({
      type: 'HOURLY',
      description: 'Ø§Ù„Ú¯ÙˆÛŒ ÙØ±ÙˆØ´ Ø¯Ø± Ø³Ø§Ø¹Ø§Øª Ù…Ø®ØªÙ„Ù Ø±ÙˆØ²',
      data: hourlyPattern,
      insight: this.generateHourlyInsight(hourlyPattern)
    });
    
    // Ø§Ù„Ú¯ÙˆÛŒ ÙØµÙ„ÛŒ
    const seasonalPattern = this.analyzeSeasonalPattern(salesData);
    patterns.push({
      type: 'SEASONAL',
      description: 'Ø§Ù„Ú¯ÙˆÛŒ ÙØµÙ„ÛŒ ÙØ±ÙˆØ´',
      data: seasonalPattern,
      insight: this.generateSeasonalInsight(seasonalPattern)
    });
    
    return patterns;
  }
}
```

### **3. Customer Analytics (ØªØ­Ù„ÛŒÙ„ Ù…Ø´ØªØ±ÛŒ)**

```typescript
class CustomerAnalytics {
  // ØªÙ‚Ø³ÛŒÙ…â€ŒØ¨Ù†Ø¯ÛŒ Ù…Ø´ØªØ±ÛŒØ§Ù† (RFM Analysis)
  async performRFMAnalysis(period: DateRange): Promise<RFMAnalysis> {
    const customers = await this.getCustomersWithTransactions(period);
    const rfmData: RFMCustomer[] = [];
    
    for (const customer of customers) {
      const transactions = await this.getCustomerTransactions(customer.id, period);
      
      // Recency: Ø±ÙˆØ²Ù‡Ø§ÛŒ Ú¯Ø°Ø´ØªÙ‡ Ø§Ø² Ø¢Ø®Ø±ÛŒÙ† Ø®Ø±ÛŒØ¯
      const lastPurchase = Math.max(...transactions.map(t => t.date.getTime()));
      const recency = Math.floor((Date.now() - lastPurchase) / (1000 * 60 * 60 * 24));
      
      // Frequency: ØªØ¹Ø¯Ø§Ø¯ Ø®Ø±ÛŒØ¯Ù‡Ø§
      const frequency = transactions.length;
      
      // Monetary: Ù…Ø¬Ù…ÙˆØ¹ Ù…Ø¨Ù„Øº Ø®Ø±ÛŒØ¯Ù‡Ø§
      const monetary = transactions.reduce((sum, t) => sum + t.totalAmount, 0);
      
      rfmData.push({
        customerId: customer.id,
        recency,
        frequency,
        monetary,
        recencyScore: this.calculateRecencyScore(recency),
        frequencyScore: this.calculateFrequencyScore(frequency),
        monetaryScore: this.calculateMonetaryScore(monetary),
        rfmScore: '', // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ø¹Ø¯Ø§Ù‹
        segment: '' // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ø¹Ø¯Ø§Ù‹
      });
    }
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù…ØªÛŒØ§Ø²Ø§Øª Ùˆ ØªÙ‚Ø³ÛŒÙ…â€ŒØ¨Ù†Ø¯ÛŒ
    const segmentedCustomers = this.segmentCustomers(rfmData);
    
    return {
      period,
      totalCustomers: customers.length,
      segments: this.groupBySegment(segmentedCustomers),
      insights: this.generateRFMInsights(segmentedCustomers)
    };
  }
  
  private segmentCustomers(rfmData: RFMCustomer[]): RFMCustomer[] {
    return rfmData.map(customer => {
      const rfmScore = `${customer.recencyScore}${customer.frequencyScore}${customer.monetaryScore}`;
      customer.rfmScore = rfmScore;
      
      // ØªØ¹ÛŒÛŒÙ† segment Ø¨Ø± Ø§Ø³Ø§Ø³ Ø§Ù…ØªÛŒØ§Ø² RFM
      if (customer.recencyScore >= 4 && customer.frequencyScore >= 4 && customer.monetaryScore >= 4) {
        customer.segment = 'Champions'; // Ù‚Ù‡Ø±Ù…Ø§Ù†Ø§Ù†
      } else if (customer.recencyScore >= 3 && customer.frequencyScore >= 3) {
        customer.segment = 'Loyal Customers'; // Ù…Ø´ØªØ±ÛŒØ§Ù† ÙˆÙØ§Ø¯Ø§Ø±
      } else if (customer.recencyScore >= 4 && customer.frequencyScore <= 2) {
        customer.segment = 'New Customers'; // Ù…Ø´ØªØ±ÛŒØ§Ù† Ø¬Ø¯ÛŒØ¯
      } else if (customer.recencyScore <= 2 && customer.frequencyScore >= 3) {
        customer.segment = 'At Risk'; // Ø¯Ø± Ù…Ø¹Ø±Ø¶ Ø®Ø·Ø±
      } else if (customer.recencyScore <= 2 && customer.frequencyScore <= 2) {
        customer.segment = 'Lost Customers'; // Ù…Ø´ØªØ±ÛŒØ§Ù† Ø§Ø² Ø¯Ø³Øª Ø±ÙØªÙ‡
      } else {
        customer.segment = 'Potential Loyalists'; // Ø¨Ø§Ù„Ù‚ÙˆÙ‡ ÙˆÙØ§Ø¯Ø§Ø±
      }
      
      return customer;
    });
  }
  
  // ØªØ­Ù„ÛŒÙ„ Ø§Ø±Ø²Ø´ Ø·ÙˆÙ„ Ø¹Ù…Ø± Ù…Ø´ØªØ±ÛŒ (CLV)
  async calculateCustomerLifetimeValue(customerId: string): Promise<CLVAnalysis> {
    const customerHistory = await this.getCustomerCompleteHistory(customerId);
    
    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ CLV
    const avgOrderValue = customerHistory.totalSpent / customerHistory.orderCount;
    const purchaseFrequency = customerHistory.orderCount / customerHistory.lifespanMonths;
    const grossMargin = await this.getCustomerGrossMargin(customerId);
    
    // CLV = (Average Order Value Ã— Purchase Frequency Ã— Gross Margin) Ã— Lifespan
    const monthlyValue = avgOrderValue * purchaseFrequency * (grossMargin / 100);
    const predictedLifespan = await this.predictCustomerLifespan(customerId);
    const clv = monthlyValue * predictedLifespan;
    
    return {
      customerId,
      currentCLV: clv,
      avgOrderValue,
      purchaseFrequency,
      grossMargin,
      predictedLifespan,
      segment: await this.getCustomerSegment(customerId),
      recommendations: this.generateCLVRecommendations(clv, avgOrderValue, purchaseFrequency)
    };
  }
}
```

---

## ğŸ“‹ **Custom Report Builder**

### **Ú¯Ø²Ø§Ø±Ø´â€ŒØ³Ø§Ø² Ù‚Ø§Ø¨Ù„ ØªÙ†Ø¸ÛŒÙ…**

```typescript
interface ReportBuilder {
  id: string;
  name: string;
  description?: string;
  type: 'TABULAR' | 'CHART' | 'DASHBOARD';
  dataSource: DataSource;
  filters: ReportFilter[];
  groupBy: string[];
  sortBy: SortOption[];
  columns: ReportColumn[];
  charts?: ChartConfig[];
  schedule?: ReportSchedule;
  exportFormats: ExportFormat[];
}

interface DataSource {
  type: 'SALES' | 'INVENTORY' | 'ACCOUNTING' | 'CUSTOM_QUERY';
  tables: string[];
  joins?: JoinConfig[];
  customQuery?: string;
}

interface ReportFilter {
  field: string;
  operator: 'EQUALS' | 'NOT_EQUALS' | 'GREATER_THAN' | 'LESS_THAN' | 'BETWEEN' | 'IN' | 'LIKE';
  value: any;
  dataType: 'STRING' | 'NUMBER' | 'DATE' | 'BOOLEAN';
}

class CustomReportBuilder {
  // Ø§ÛŒØ¬Ø§Ø¯ Ú¯Ø²Ø§Ø±Ø´ Ø¬Ø¯ÛŒØ¯
  async createReport(config: ReportBuilder): Promise<Report> {
    // Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª
    this.validateReportConfig(config);
    
    // Ø³Ø§Ø®Øª Ú©ÙˆØ¦Ø±ÛŒ
    const query = await this.buildQuery(config);
    
    // Ø§Ø¬Ø±Ø§ÛŒ Ú©ÙˆØ¦Ø±ÛŒ Ùˆ Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
    const data = await this.executeQuery(query);
    
    // Ø§Ø¹Ù…Ø§Ù„ ÙÛŒÙ„ØªØ±Ù‡Ø§ Ùˆ Ù…Ø±ØªØ¨â€ŒØ³Ø§Ø²ÛŒ
    const processedData = this.processData(data, config);
    
    // ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´
    const report: Report = {
      id: config.id,
      name: config.name,
      generatedAt: new Date(),
      data: processedData,
      metadata: {
        totalRows: processedData.length,
        columns: config.columns,
        filters: config.filters,
        executionTime: 0 // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯Ù‡
      }
    };
    
    return report;
  }
  
  // Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§ÛŒ Ø§Ø² Ù¾ÛŒØ´ ØªØ¹Ø±ÛŒÙ Ø´Ø¯Ù‡
  async getPrebuiltReports(): Promise<ReportTemplate[]> {
    return [
      {
        id: 'sales-summary',
        name: 'Ø®Ù„Ø§ØµÙ‡ ÙØ±ÙˆØ´',
        description: 'Ú¯Ø²Ø§Ø±Ø´ Ø®Ù„Ø§ØµÙ‡ ÙØ±ÙˆØ´ Ø±ÙˆØ²Ø§Ù†Ù‡ØŒ Ù‡ÙØªÚ¯ÛŒØŒ Ù…Ø§Ù‡Ø§Ù†Ù‡',
        category: 'SALES',
        config: {
          dataSource: { type: 'SALES', tables: ['pos_transactions', 'pos_transaction_items'] },
          columns: [
            { field: 'date', label: 'ØªØ§Ø±ÛŒØ®', type: 'DATE' },
            { field: 'total_amount', label: 'Ù…Ø¨Ù„Øº Ú©Ù„', type: 'CURRENCY' },
            { field: 'transaction_count', label: 'ØªØ¹Ø¯Ø§Ø¯ ØªØ±Ø§Ú©Ù†Ø´', type: 'NUMBER' },
            { field: 'avg_order_value', label: 'Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø³ÙØ§Ø±Ø´', type: 'CURRENCY' }
          ],
          groupBy: ['date'],
          sortBy: [{ field: 'date', direction: 'DESC' }]
        }
      },
      {
        id: 'inventory-status',
        name: 'ÙˆØ¶Ø¹ÛŒØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ',
        description: 'Ú¯Ø²Ø§Ø±Ø´ ÙˆØ¶Ø¹ÛŒØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©Ø§Ù„Ø§Ù‡Ø§',
        category: 'INVENTORY',
        config: {
          dataSource: { type: 'INVENTORY', tables: ['items', 'categories'] },
          columns: [
            { field: 'item_name', label: 'Ù†Ø§Ù… Ú©Ø§Ù„Ø§', type: 'STRING' },
            { field: 'category_name', label: 'Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ', type: 'STRING' },
            { field: 'current_quantity', label: 'Ù…ÙˆØ¬ÙˆØ¯ÛŒ ÙØ¹Ù„ÛŒ', type: 'NUMBER' },
            { field: 'min_quantity', label: 'Ø­Ø¯Ø§Ù‚Ù„ Ù…ÙˆØ¬ÙˆØ¯ÛŒ', type: 'NUMBER' },
            { field: 'status', label: 'ÙˆØ¶Ø¹ÛŒØª', type: 'STRING' }
          ],
          filters: [
            { field: 'is_active', operator: 'EQUALS', value: true, dataType: 'BOOLEAN' }
          ]
        }
      },
      {
        id: 'profit-analysis',
        name: 'ØªØ­Ù„ÛŒÙ„ Ø³ÙˆØ¯Ø¢ÙˆØ±ÛŒ',
        description: 'ØªØ­Ù„ÛŒÙ„ Ø³ÙˆØ¯Ø¢ÙˆØ±ÛŒ Ù…Ø­ØµÙˆÙ„Ø§Øª Ùˆ Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒâ€ŒÙ‡Ø§',
        category: 'FINANCIAL',
        config: {
          dataSource: { 
            type: 'CUSTOM_QUERY',
            customQuery: `
              SELECT 
                i.name as item_name,
                c.name as category_name,
                SUM(pti.quantity) as total_sold,
                SUM(pti.total_price) as total_revenue,
                SUM(pti.quantity * i.cost_price) as total_cost,
                SUM(pti.total_price - (pti.quantity * i.cost_price)) as total_profit,
                ROUND(
                  (SUM(pti.total_price - (pti.quantity * i.cost_price)) / SUM(pti.total_price)) * 100, 
                  2
                ) as profit_margin
              FROM pos_transaction_items pti
              JOIN items i ON pti.item_id = i.id
              JOIN categories c ON i.category_id = c.id
              JOIN pos_transactions pt ON pti.transaction_id = pt.id
              WHERE pt.transaction_at >= ? AND pt.transaction_at <= ?
              GROUP BY i.id, i.name, c.name
              ORDER BY total_profit DESC
            `
          },
          columns: [
            { field: 'item_name', label: 'Ù†Ø§Ù… Ú©Ø§Ù„Ø§', type: 'STRING' },
            { field: 'category_name', label: 'Ø¯Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ', type: 'STRING' },
            { field: 'total_sold', label: 'ØªØ¹Ø¯Ø§Ø¯ ÙØ±ÙˆØ®ØªÙ‡ Ø´Ø¯Ù‡', type: 'NUMBER' },
            { field: 'total_revenue', label: 'Ø¯Ø±Ø¢Ù…Ø¯ Ú©Ù„', type: 'CURRENCY' },
            { field: 'total_cost', label: 'Ù‡Ø²ÛŒÙ†Ù‡ Ú©Ù„', type: 'CURRENCY' },
            { field: 'total_profit', label: 'Ø³ÙˆØ¯ Ú©Ù„', type: 'CURRENCY' },
            { field: 'profit_margin', label: 'Ø­Ø§Ø´ÛŒÙ‡ Ø³ÙˆØ¯ (%)', type: 'PERCENTAGE' }
          ]
        }
      }
    ];
  }
  
  // Ø²Ù…Ø§Ù†â€ŒØ¨Ù†Ø¯ÛŒ Ú¯Ø²Ø§Ø±Ø´â€ŒÙ‡Ø§
  async scheduleReport(
    reportId: string, 
    schedule: ReportSchedule
  ): Promise<ScheduledReport> {
    const scheduledReport: ScheduledReport = {
      id: generateId(),
      reportId,
      schedule,
      isActive: true,
      lastRun: null,
      nextRun: this.calculateNextRun(schedule),
      recipients: schedule.recipients,
      createdAt: new Date()
    };
    
    // Ø«Ø¨Øª Ø¯Ø± Ø³ÛŒØ³ØªÙ… Ø²Ù…Ø§Ù†â€ŒØ¨Ù†Ø¯ÛŒ
    await this.saveScheduledReport(scheduledReport);
    
    // ØªÙ†Ø¸ÛŒÙ… cron job
    this.setupCronJob(scheduledReport);
    
    return scheduledReport;
  }
}
```

---

## ğŸ“¤ **Export System**

### **Ø³ÛŒØ³ØªÙ… Ø®Ø±ÙˆØ¬ÛŒ Ú†Ù†Ø¯ÙØ±Ù…ØªÙ‡**

```typescript
class ReportExportSystem {
  // Ø®Ø±ÙˆØ¬ÛŒ Excel
  async exportToExcel(
    report: Report, 
    options: ExcelExportOptions = {}
  ): Promise<Buffer> {
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet(report.name);
    
    // ØªÙ†Ø¸ÛŒÙ… Ù‡Ø¯Ø±Ù‡Ø§
    const headers = report.metadata.columns.map(col => col.label);
    worksheet.addRow(headers);
    
    // Ø§Ø³ØªØ§ÛŒÙ„ Ù‡Ø¯Ø±Ù‡Ø§
    const headerRow = worksheet.getRow(1);
    headerRow.font = { bold: true, color: { argb: 'FFFFFF' } };
    headerRow.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: '366092' } };
    
    // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
    report.data.forEach(row => {
      const values = report.metadata.columns.map(col => {
        const value = row[col.field];
        return this.formatCellValue(value, col.type);
      });
      worksheet.addRow(values);
    });
    
    // ØªÙ†Ø¸ÛŒÙ… Ø¹Ø±Ø¶ Ø³ØªÙˆÙ†â€ŒÙ‡Ø§
    worksheet.columns.forEach(column => {
      column.width = 15;
    });
    
    // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ú†Ø§Ø±Øª (Ø§Ø®ØªÛŒØ§Ø±ÛŒ)
    if (options.includeCharts && report.charts) {
      await this.addChartsToWorksheet(worksheet, report.charts);
    }
    
    return await workbook.xlsx.writeBuffer();
  }
  
  // Ø®Ø±ÙˆØ¬ÛŒ PDF
  async exportToPDF(
    report: Report, 
    options: PDFExportOptions = {}
  ): Promise<Buffer> {
    const doc = new PDFDocument({ margin: 50 });
    const buffers: Buffer[] = [];
    
    doc.on('data', buffers.push.bind(buffers));
    
    // Ù‡Ø¯Ø± Ú¯Ø²Ø§Ø±Ø´
    doc.fontSize(16).font('Helvetica-Bold').text(report.name, { align: 'center' });
    doc.fontSize(10).text(`ØªØ§Ø±ÛŒØ® ØªÙˆÙ„ÛŒØ¯: ${new Date().toLocaleDateString('fa-IR')}`, { align: 'left' });
    doc.moveDown();
    
    // Ø¬Ø¯ÙˆÙ„ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
    const table = {
      headers: report.metadata.columns.map(col => col.label),
      rows: report.data.map(row => 
        report.metadata.columns.map(col => 
          this.formatCellValue(row[col.field], col.type)
        )
      )
    };
    
    await this.drawTable(doc, table);
    
    // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ú†Ø§Ø±Øªâ€ŒÙ‡Ø§
    if (options.includeCharts && report.charts) {
      doc.addPage();
      await this.addChartsToPDF(doc, report.charts);
    }
    
    doc.end();
    
    return new Promise(resolve => {
      doc.on('end', () => {
        resolve(Buffer.concat(buffers));
      });
    });
  }
  
  // Ø®Ø±ÙˆØ¬ÛŒ CSV
  async exportToCSV(report: Report): Promise<string> {
    const headers = report.metadata.columns.map(col => col.label);
    const rows = report.data.map(row => 
      report.metadata.columns.map(col => {
        const value = row[col.field];
        return this.escapeCsvValue(this.formatCellValue(value, col.type));
      })
    );
    
    const csvContent = [
      headers.join(','),
      ...rows.map(row => row.join(','))
    ].join('\n');
    
    // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† BOM Ø¨Ø±Ø§ÛŒ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø§Ø² UTF-8 Ø¯Ø± Excel
    return '\ufeff' + csvContent;
  }
  
  // Ø®Ø±ÙˆØ¬ÛŒ JSON
  async exportToJSON(report: Report): Promise<string> {
    const exportData = {
      reportName: report.name,
      generatedAt: report.generatedAt,
      metadata: report.metadata,
      data: report.data
    };
    
    return JSON.stringify(exportData, null, 2);
  }
  
  private formatCellValue(value: any, type: string): string {
    if (value === null || value === undefined) return '';
    
    switch (type) {
      case 'CURRENCY':
        return new Intl.NumberFormat('fa-IR', {
          style: 'currency',
          currency: 'IRR'
        }).format(value);
      case 'PERCENTAGE':
        return `${value}%`;
      case 'DATE':
        return new Date(value).toLocaleDateString('fa-IR');
      case 'NUMBER':
        return new Intl.NumberFormat('fa-IR').format(value);
      default:
        return String(value);
    }
  }
}
```

---

## ğŸš¨ **Alert System**

### **Ø³ÛŒØ³ØªÙ… Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯**

```typescript
class IntelligentAlertSystem {
  // ØªØ¹Ø±ÛŒÙ Ù‚ÙˆØ§Ù†ÛŒÙ† Ù‡Ø´Ø¯Ø§Ø±
  async defineAlertRules(): Promise<AlertRule[]> {
    return [
      {
        id: 'low-stock-alert',
        name: 'Ù‡Ø´Ø¯Ø§Ø± Ú©Ù…Ø¨ÙˆØ¯ Ù…ÙˆØ¬ÙˆØ¯ÛŒ',
        description: 'Ù‡Ø´Ø¯Ø§Ø± Ø²Ù…Ø§Ù†ÛŒ Ú©Ù‡ Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©Ø§Ù„Ø§ Ø¨Ù‡ Ø­Ø¯Ø§Ù‚Ù„ Ø¨Ø±Ø³Ø¯',
        condition: {
          metric: 'current_quantity',
          operator: 'LESS_THAN_OR_EQUAL',
          threshold: 'min_quantity',
          entity: 'ITEM'
        },
        severity: 'WARNING',
        frequency: 'REAL_TIME',
        recipients: ['inventory@servaan.com', 'manager@servaan.com']
      },
      {
        id: 'high-profit-opportunity',
        name: 'ÙØ±ØµØª Ø³ÙˆØ¯ Ø¨Ø§Ù„Ø§',
        description: 'Ù‡Ø´Ø¯Ø§Ø± Ø²Ù…Ø§Ù†ÛŒ Ú©Ù‡ Ù…Ø­ØµÙˆÙ„ÛŒ Ø³ÙˆØ¯ Ø¨Ø§Ù„Ø§ÛŒÛŒ Ø¯Ø§Ø±Ø¯',
        condition: {
          metric: 'profit_margin',
          operator: 'GREATER_THAN',
          threshold: 50, // Ø¨ÛŒØ´ Ø§Ø² 50% Ø³ÙˆØ¯
          entity: 'ITEM'
        },
        severity: 'INFO',
        frequency: 'DAILY',
        recipients: ['sales@servaan.com']
      },
      {
        id: 'sales-drop-alert',
        name: 'Ù‡Ø´Ø¯Ø§Ø± Ú©Ø§Ù‡Ø´ ÙØ±ÙˆØ´',
        description: 'Ù‡Ø´Ø¯Ø§Ø± Ø²Ù…Ø§Ù†ÛŒ Ú©Ù‡ ÙØ±ÙˆØ´ Ø±ÙˆØ²Ø§Ù†Ù‡ Ú©Ø§Ù‡Ø´ ÛŒØ§Ø¨Ø¯',
        condition: {
          metric: 'daily_sales',
          operator: 'LESS_THAN',
          threshold: 'previous_week_average * 0.8', // 20% Ú©Ø§Ù‡Ø´
          entity: 'SALES'
        },
        severity: 'CRITICAL',
        frequency: 'DAILY',
        recipients: ['manager@servaan.com', 'sales@servaan.com']
      },
      {
        id: 'customer-churn-risk',
        name: 'Ø®Ø·Ø± Ø§Ø² Ø¯Ø³Øª Ø¯Ø§Ø¯Ù† Ù…Ø´ØªØ±ÛŒ',
        description: 'Ù‡Ø´Ø¯Ø§Ø± Ø¨Ø±Ø§ÛŒ Ù…Ø´ØªØ±ÛŒØ§Ù†ÛŒ Ú©Ù‡ Ù…Ø¯ØªÛŒ Ø®Ø±ÛŒØ¯ Ù†Ú©Ø±Ø¯Ù‡â€ŒØ§Ù†Ø¯',
        condition: {
          metric: 'days_since_last_purchase',
          operator: 'GREATER_THAN',
          threshold: 30, // 30 Ø±ÙˆØ² Ø¹Ø¯Ù… Ø®Ø±ÛŒØ¯
          entity: 'CUSTOMER'
        },
        severity: 'WARNING',
        frequency: 'WEEKLY',
        recipients: ['crm@servaan.com']
      }
    ];
  }
  
  // Ø¨Ø±Ø±Ø³ÛŒ Ùˆ Ø§Ø±Ø³Ø§Ù„ Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§
  async checkAndSendAlerts(): Promise<AlertExecution[]> {
    const rules = await this.getActiveAlertRules();
    const executions: AlertExecution[] = [];
    
    for (const rule of rules) {
      try {
        const triggeredAlerts = await this.evaluateRule(rule);
        
        if (triggeredAlerts.length > 0) {
          const execution = await this.sendAlert(rule, triggeredAlerts);
          executions.push(execution);
        }
      } catch (error) {
        console.error(`Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±Ø±Ø³ÛŒ Ù‚Ø§Ù†ÙˆÙ† ${rule.id}:`, error);
      }
    }
    
    return executions;
  }
  
  private async evaluateRule(rule: AlertRule): Promise<AlertTrigger[]> {
    const triggers: AlertTrigger[] = [];
    
    switch (rule.condition.entity) {
      case 'ITEM':
        const items = await this.getAllActiveItems();
        for (const item of items) {
          if (await this.evaluateItemCondition(item, rule.condition)) {
            triggers.push({
              entityType: 'ITEM',
              entityId: item.id,
              entityName: item.name,
              currentValue: await this.getMetricValue(item, rule.condition.metric),
              threshold: rule.condition.threshold
            });
          }
        }
        break;
        
      case 'SALES':
        if (await this.evaluateSalesCondition(rule.condition)) {
          triggers.push({
            entityType: 'SALES',
            entityId: 'daily_sales',
            entityName: 'ÙØ±ÙˆØ´ Ø±ÙˆØ²Ø§Ù†Ù‡',
            currentValue: await this.getDailySales(),
            threshold: rule.condition.threshold
          });
        }
        break;
        
      case 'CUSTOMER':
        const customers = await this.getActiveCustomers();
        for (const customer of customers) {
          if (await this.evaluateCustomerCondition(customer, rule.condition)) {
            triggers.push({
              entityType: 'CUSTOMER',
              entityId: customer.id,
              entityName: customer.name || customer.phone,
              currentValue: await this.getCustomerMetricValue(customer, rule.condition.metric),
              threshold: rule.condition.threshold
            });
          }
        }
        break;
    }
    
    return triggers;
  }
  
  private async sendAlert(
    rule: AlertRule, 
    triggers: AlertTrigger[]
  ): Promise<AlertExecution> {
    const alertMessage = this.generateAlertMessage(rule, triggers);
    
    // Ø§Ø±Ø³Ø§Ù„ Ø§ÛŒÙ…ÛŒÙ„
    await this.sendEmailAlert(rule.recipients, alertMessage);
    
    // Ø§Ø±Ø³Ø§Ù„ Ù†ÙˆØªÛŒÙÛŒÚ©ÛŒØ´Ù† Ø¯Ø± Ø³ÛŒØ³ØªÙ…
    await this.sendSystemNotification(rule, triggers);
    
    // Ø«Ø¨Øª Ø¯Ø± Ù„Ø§Ú¯
    const execution: AlertExecution = {
      id: generateId(),
      ruleId: rule.id,
      executedAt: new Date(),
      triggersCount: triggers.length,
      recipients: rule.recipients,
      status: 'SENT',
      message: alertMessage
    };
    
    await this.logAlertExecution(execution);
    
    return execution;
  }
  
  private generateAlertMessage(rule: AlertRule, triggers: AlertTrigger[]): string {
    let message = `ğŸš¨ ${rule.name}\n\n`;
    message += `${rule.description}\n\n`;
    
    if (triggers.length === 1) {
      const trigger = triggers[0];
      message += `Ù…ÙˆØ¬ÙˆØ¯ÛŒØª: ${trigger.entityName}\n`;
      message += `Ù…Ù‚Ø¯Ø§Ø± ÙØ¹Ù„ÛŒ: ${trigger.currentValue}\n`;
      message += `Ø¢Ø³ØªØ§Ù†Ù‡: ${trigger.threshold}\n`;
    } else {
      message += `ØªØ¹Ø¯Ø§Ø¯ Ù…ÙˆØ§Ø±Ø¯: ${triggers.length}\n\n`;
      triggers.slice(0, 5).forEach(trigger => {
        message += `â€¢ ${trigger.entityName}: ${trigger.currentValue}\n`;
      });
      
      if (triggers.length > 5) {
        message += `... Ùˆ ${triggers.length - 5} Ù…ÙˆØ±Ø¯ Ø¯ÛŒÚ¯Ø±\n`;
      }
    }
    
    message += `\nØ²Ù…Ø§Ù†: ${new Date().toLocaleString('fa-IR')}`;
    
    return message;
  }
}
```

**ğŸ¯ Ø³ÛŒØ³ØªÙ… Business Intelligence Ú©Ø§Ù…Ù„ Ø¢Ù…Ø§Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø§Ø³Øª! ØªÙ…Ø§Ù… ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§ÛŒ KPIØŒ ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡ØŒ Ú¯Ø²Ø§Ø±Ø´â€ŒØ³Ø§Ø² Ùˆ Ù‡Ø´Ø¯Ø§Ø±Ù‡Ø§ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯ Ø·Ø±Ø§Ø­ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª.** 